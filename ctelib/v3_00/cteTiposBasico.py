#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Mon Oct  9 15:35:30 2017 by generateDS.py version 2.28b.
# Python 2.7.12 (default, Nov 19 2016, 06:48:10)  [GCC 5.4.0 20160609]
#
# Command line options:
#   ('--no-process-includes', '')
#   ('-o', 'ctelib/v3_00/cteTiposBasico.py')
#
# Command line arguments:
#   schemas/v3_00/cteTiposBasico_v3.00.xsd
#
# Command line:
#   /usr/local/bin/generateDS --no-process-includes -o "ctelib/v3_00/cteTiposBasico.py" schemas/v3_00/cteTiposBasico_v3.00.xsd
#
# Current working directory (os.getcwd()):
#   ctelib
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for a example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.  We should:
            # - AND the outer elements
            # - OR the inner elements
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    if re_.search(patterns2, target) is not None:
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                return instring.encode(ExternalEncoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            if type(self) != type(other):
                return False
            return self.__dict__ == other.__dict__
        def __ne__(self, other):
            return not self.__eq__(other)
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class TProtCTeOS(GeneratedsSuper):
    """Tipo Protocolo de status resultado do processamento do CT-e OS
    (Modelo 67)"""
    subclass = None
    superclass = None
    def __init__(self, versao=None, infProt=None, Signature=None):
        self.original_tagname_ = None
        self.versao = _cast(None, versao)
        self.infProt = infProt
        self.Signature = Signature
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TProtCTeOS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TProtCTeOS.subclass:
            return TProtCTeOS.subclass(*args_, **kwargs_)
        else:
            return TProtCTeOS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_infProt(self): return self.infProt
    def set_infProt(self, infProt): self.infProt = infProt
    def get_Signature(self): return self.Signature
    def set_Signature(self, Signature): self.Signature = Signature
    def get_versao(self): return self.versao
    def set_versao(self, versao): self.versao = versao
    def validate_TVerCTe(self, value):
        # Validate type TVerCTe, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.infProt is not None or
            self.Signature is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TProtCTeOS', namespacedef_=' xmlns:ds="http://www.w3.org/2000/09/xmldsig#" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TProtCTeOS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TProtCTeOS')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TProtCTeOS', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TProtCTeOS'):
        if self.versao is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            outfile.write(' versao=%s' % (quote_attrib(self.versao), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TProtCTeOS', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.infProt is not None:
            self.infProt.export(outfile, level, namespace_, name_='infProt', pretty_print=pretty_print)
        if self.Signature is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSignature>%s</%sSignature>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Signature), input_name='Signature')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('versao', node)
        if value is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            self.versao = value
            self.validate_TVerCTe(self.versao)    # validate type TVerCTe
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'infProt':
            obj_ = infProt.factory()
            obj_.build(child_)
            self.infProt = obj_
            obj_.original_tagname_ = 'infProt'
        elif nodeName_ == 'Signature':
            Signature_ = child_.text
            Signature_ = self.gds_validate_string(Signature_, node, 'Signature')
            self.Signature = Signature_
# end class TProtCTeOS


class infProt(GeneratedsSuper):
    """Dados do protocolo de status"""
    subclass = None
    superclass = None
    def __init__(self, Id=None, tpAmb=None, verAplic=None, chCTe=None, dhRecbto=None, nProt=None, digVal=None, cStat=None, xMotivo=None):
        self.original_tagname_ = None
        self.Id = _cast(None, Id)
        self.tpAmb = tpAmb
        self.verAplic = verAplic
        self.chCTe = chCTe
        self.dhRecbto = dhRecbto
        self.nProt = nProt
        self.digVal = digVal
        self.cStat = cStat
        self.xMotivo = xMotivo
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infProt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infProt.subclass:
            return infProt.subclass(*args_, **kwargs_)
        else:
            return infProt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tpAmb(self): return self.tpAmb
    def set_tpAmb(self, tpAmb): self.tpAmb = tpAmb
    def get_verAplic(self): return self.verAplic
    def set_verAplic(self, verAplic): self.verAplic = verAplic
    def get_chCTe(self): return self.chCTe
    def set_chCTe(self, chCTe): self.chCTe = chCTe
    def get_dhRecbto(self): return self.dhRecbto
    def set_dhRecbto(self, dhRecbto): self.dhRecbto = dhRecbto
    def get_nProt(self): return self.nProt
    def set_nProt(self, nProt): self.nProt = nProt
    def get_digVal(self): return self.digVal
    def set_digVal(self, digVal): self.digVal = digVal
    def get_cStat(self): return self.cStat
    def set_cStat(self, cStat): self.cStat = cStat
    def get_xMotivo(self): return self.xMotivo
    def set_xMotivo(self, xMotivo): self.xMotivo = xMotivo
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def hasContent_(self):
        if (
            self.tpAmb is not None or
            self.verAplic is not None or
            self.chCTe is not None or
            self.dhRecbto is not None or
            self.nProt is not None or
            self.digVal is not None or
            self.cStat is not None or
            self.xMotivo is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infProt', namespacedef_=' xmlns:ds="http://www.w3.org/2000/09/xmldsig#" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infProt')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infProt')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infProt', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infProt'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Id), input_name='Id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='infProt', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpAmb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpAmb>%s</%stpAmb>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.tpAmb), input_name='tpAmb')), namespace_, eol_))
        if self.verAplic is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sverAplic>%s</%sverAplic>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.verAplic), input_name='verAplic')), namespace_, eol_))
        if self.chCTe is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%schCTe>%s</%schCTe>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.chCTe), input_name='chCTe')), namespace_, eol_))
        if self.dhRecbto is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdhRecbto>%s</%sdhRecbto>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.dhRecbto), input_name='dhRecbto')), namespace_, eol_))
        if self.nProt is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snProt>%s</%snProt>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.nProt), input_name='nProt')), namespace_, eol_))
        if self.digVal is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdigVal>%s</%sdigVal>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.digVal), input_name='digVal')), namespace_, eol_))
        if self.cStat is not None:
            self.cStat.export(outfile, level, namespace_, name_='cStat', pretty_print=pretty_print)
        if self.xMotivo is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxMotivo>%s</%sxMotivo>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.xMotivo), input_name='xMotivo')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tpAmb':
            tpAmb_ = child_.text
            tpAmb_ = self.gds_validate_string(tpAmb_, node, 'tpAmb')
            self.tpAmb = tpAmb_
        elif nodeName_ == 'verAplic':
            verAplic_ = child_.text
            verAplic_ = self.gds_validate_string(verAplic_, node, 'verAplic')
            self.verAplic = verAplic_
        elif nodeName_ == 'chCTe':
            chCTe_ = child_.text
            chCTe_ = self.gds_validate_string(chCTe_, node, 'chCTe')
            self.chCTe = chCTe_
        elif nodeName_ == 'dhRecbto':
            dhRecbto_ = child_.text
            dhRecbto_ = self.gds_validate_string(dhRecbto_, node, 'dhRecbto')
            self.dhRecbto = dhRecbto_
        elif nodeName_ == 'nProt':
            nProt_ = child_.text
            nProt_ = self.gds_validate_string(nProt_, node, 'nProt')
            self.nProt = nProt_
        elif nodeName_ == 'digVal':
            digVal_ = child_.text
            digVal_ = self.gds_validate_string(digVal_, node, 'digVal')
            self.digVal = digVal_
        elif nodeName_ == 'cStat':
            obj_ = None
            self.cStat = obj_
            obj_.original_tagname_ = 'cStat'
        elif nodeName_ == 'xMotivo':
            xMotivo_ = child_.text
            xMotivo_ = self.gds_validate_string(xMotivo_, node, 'xMotivo')
            self.xMotivo = xMotivo_
# end class infProt


class cStat(GeneratedsSuper):
    """Código do status do CT-e."""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cStat)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cStat.subclass:
            return cStat.subclass(*args_, **kwargs_)
        else:
            return cStat(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cStat', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cStat')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cStat')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='cStat', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cStat'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='cStat', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cStat


class TRetCTeOS(GeneratedsSuper):
    """Tipo Retorno do Pedido de Autorização de CT-e OS (Modelo 67)"""
    subclass = None
    superclass = None
    def __init__(self, versao=None, tpAmb=None, cUF=None, verAplic=None, cStat=None, xMotivo=None, protCTe=None):
        self.original_tagname_ = None
        self.versao = _cast(None, versao)
        self.tpAmb = tpAmb
        self.cUF = cUF
        self.verAplic = verAplic
        self.cStat = cStat
        self.xMotivo = xMotivo
        self.protCTe = protCTe
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TRetCTeOS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TRetCTeOS.subclass:
            return TRetCTeOS.subclass(*args_, **kwargs_)
        else:
            return TRetCTeOS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tpAmb(self): return self.tpAmb
    def set_tpAmb(self, tpAmb): self.tpAmb = tpAmb
    def get_cUF(self): return self.cUF
    def set_cUF(self, cUF): self.cUF = cUF
    def get_verAplic(self): return self.verAplic
    def set_verAplic(self, verAplic): self.verAplic = verAplic
    def get_cStat(self): return self.cStat
    def set_cStat(self, cStat): self.cStat = cStat
    def get_xMotivo(self): return self.xMotivo
    def set_xMotivo(self, xMotivo): self.xMotivo = xMotivo
    def get_protCTe(self): return self.protCTe
    def set_protCTe(self, protCTe): self.protCTe = protCTe
    def get_versao(self): return self.versao
    def set_versao(self, versao): self.versao = versao
    def validate_TVerCTe(self, value):
        # Validate type TVerCTe, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.tpAmb is not None or
            self.cUF is not None or
            self.verAplic is not None or
            self.cStat is not None or
            self.xMotivo is not None or
            self.protCTe is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TRetCTeOS', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TRetCTeOS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TRetCTeOS')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TRetCTeOS', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TRetCTeOS'):
        if self.versao is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            outfile.write(' versao=%s' % (quote_attrib(self.versao), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TRetCTeOS', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpAmb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpAmb>%s</%stpAmb>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.tpAmb), input_name='tpAmb')), namespace_, eol_))
        if self.cUF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scUF>%s</%scUF>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.cUF), input_name='cUF')), namespace_, eol_))
        if self.verAplic is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sverAplic>%s</%sverAplic>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.verAplic), input_name='verAplic')), namespace_, eol_))
        if self.cStat is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scStat>%s</%scStat>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.cStat), input_name='cStat')), namespace_, eol_))
        if self.xMotivo is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxMotivo>%s</%sxMotivo>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.xMotivo), input_name='xMotivo')), namespace_, eol_))
        if self.protCTe is not None:
            self.protCTe.export(outfile, level, namespace_, name_='protCTe', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('versao', node)
        if value is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            self.versao = value
            self.validate_TVerCTe(self.versao)    # validate type TVerCTe
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tpAmb':
            tpAmb_ = child_.text
            tpAmb_ = self.gds_validate_string(tpAmb_, node, 'tpAmb')
            self.tpAmb = tpAmb_
        elif nodeName_ == 'cUF':
            cUF_ = child_.text
            cUF_ = self.gds_validate_string(cUF_, node, 'cUF')
            self.cUF = cUF_
        elif nodeName_ == 'verAplic':
            verAplic_ = child_.text
            verAplic_ = self.gds_validate_string(verAplic_, node, 'verAplic')
            self.verAplic = verAplic_
        elif nodeName_ == 'cStat':
            cStat_ = child_.text
            cStat_ = self.gds_validate_string(cStat_, node, 'cStat')
            self.cStat = cStat_
        elif nodeName_ == 'xMotivo':
            xMotivo_ = child_.text
            xMotivo_ = self.gds_validate_string(xMotivo_, node, 'xMotivo')
            self.xMotivo = xMotivo_
        elif nodeName_ == 'protCTe':
            obj_ = TProtCTeOS.factory()
            obj_.build(child_)
            self.protCTe = obj_
            obj_.original_tagname_ = 'protCTe'
# end class TRetCTeOS


class TCTe(GeneratedsSuper):
    """Tipo Conhecimento de Transporte Eletrônico (Modelo 57)"""
    subclass = None
    superclass = None
    def __init__(self, infCte=None, Signature=None):
        self.original_tagname_ = None
        self.infCte = infCte
        self.Signature = Signature
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TCTe)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TCTe.subclass:
            return TCTe.subclass(*args_, **kwargs_)
        else:
            return TCTe(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_infCte(self): return self.infCte
    def set_infCte(self, infCte): self.infCte = infCte
    def get_Signature(self): return self.Signature
    def set_Signature(self, Signature): self.Signature = Signature
    def hasContent_(self):
        if (
            self.infCte is not None or
            self.Signature is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TCTe', namespacedef_=' xmlns:ds="http://www.w3.org/2000/09/xmldsig#" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TCTe')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TCTe')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TCTe', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TCTe'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TCTe', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.infCte is not None:
            self.infCte.export(outfile, level, namespace_, name_='infCte', pretty_print=pretty_print)
        if self.Signature is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSignature>%s</%sSignature>%s' % ('ds:', self.gds_encode(self.gds_format_string(quote_xml(self.Signature), input_name='Signature')), 'ds:', eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'infCte':
            obj_ = infCte.factory()
            obj_.build(child_)
            self.infCte = obj_
            obj_.original_tagname_ = 'infCte'
        elif nodeName_ == 'Signature':
            Signature_ = child_.text
            Signature_ = self.gds_validate_string(Signature_, node, 'Signature')
            self.Signature = Signature_
# end class TCTe


class infCte(GeneratedsSuper):
    """ Informações do CT-eVersão do leiauteEx: "3.00"Identificador da tag a
    ser assinadaInformar a chave de acesso do CT-e e precedida do
    literal "CTe" """
    subclass = None
    superclass = None
    def __init__(self, versao=None, Id=None, ide=None, compl=None, emit=None, rem=None, exped=None, receb=None, dest=None, vPrest=None, imp=None, infCTeNorm=None, infCteComp=None, infCteAnu=None, autXML=None):
        self.original_tagname_ = None
        self.versao = _cast(None, versao)
        self.Id = _cast(None, Id)
        self.ide = ide
        self.compl = compl
        self.emit = emit
        self.rem = rem
        self.exped = exped
        self.receb = receb
        self.dest = dest
        self.vPrest = vPrest
        self.imp = imp
        self.infCTeNorm = infCTeNorm
        self.infCteComp = infCteComp
        self.infCteAnu = infCteAnu
        if autXML is None:
            self.autXML = []
        else:
            self.autXML = autXML
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infCte)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infCte.subclass:
            return infCte.subclass(*args_, **kwargs_)
        else:
            return infCte(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ide(self): return self.ide
    def set_ide(self, ide): self.ide = ide
    def get_compl(self): return self.compl
    def set_compl(self, compl): self.compl = compl
    def get_emit(self): return self.emit
    def set_emit(self, emit): self.emit = emit
    def get_rem(self): return self.rem
    def set_rem(self, rem): self.rem = rem
    def get_exped(self): return self.exped
    def set_exped(self, exped): self.exped = exped
    def get_receb(self): return self.receb
    def set_receb(self, receb): self.receb = receb
    def get_dest(self): return self.dest
    def set_dest(self, dest): self.dest = dest
    def get_vPrest(self): return self.vPrest
    def set_vPrest(self, vPrest): self.vPrest = vPrest
    def get_imp(self): return self.imp
    def set_imp(self, imp): self.imp = imp
    def get_infCTeNorm(self): return self.infCTeNorm
    def set_infCTeNorm(self, infCTeNorm): self.infCTeNorm = infCTeNorm
    def get_infCteComp(self): return self.infCteComp
    def set_infCteComp(self, infCteComp): self.infCteComp = infCteComp
    def get_infCteAnu(self): return self.infCteAnu
    def set_infCteAnu(self, infCteAnu): self.infCteAnu = infCteAnu
    def get_autXML(self): return self.autXML
    def set_autXML(self, autXML): self.autXML = autXML
    def add_autXML(self, value): self.autXML.append(value)
    def insert_autXML_at(self, index, value): self.autXML.insert(index, value)
    def replace_autXML_at(self, index, value): self.autXML[index] = value
    def get_versao(self): return self.versao
    def set_versao(self, versao): self.versao = versao
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def validate_TVerCTe(self, value):
        # Validate type TVerCTe, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.ide is not None or
            self.compl is not None or
            self.emit is not None or
            self.rem is not None or
            self.exped is not None or
            self.receb is not None or
            self.dest is not None or
            self.vPrest is not None or
            self.imp is not None or
            self.infCTeNorm is not None or
            self.infCteComp is not None or
            self.infCteAnu is not None or
            self.autXML
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infCte', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infCte')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infCte')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infCte', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infCte'):
        if self.versao is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            outfile.write(' versao=%s' % (quote_attrib(self.versao), ))
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Id), input_name='Id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='infCte', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ide is not None:
            self.ide.export(outfile, level, namespace_, name_='ide', pretty_print=pretty_print)
        if self.compl is not None:
            self.compl.export(outfile, level, namespace_, name_='compl', pretty_print=pretty_print)
        if self.emit is not None:
            self.emit.export(outfile, level, namespace_, name_='emit', pretty_print=pretty_print)
        if self.rem is not None:
            self.rem.export(outfile, level, namespace_, name_='rem', pretty_print=pretty_print)
        if self.exped is not None:
            self.exped.export(outfile, level, namespace_, name_='exped', pretty_print=pretty_print)
        if self.receb is not None:
            self.receb.export(outfile, level, namespace_, name_='receb', pretty_print=pretty_print)
        if self.dest is not None:
            self.dest.export(outfile, level, namespace_, name_='dest', pretty_print=pretty_print)
        if self.vPrest is not None:
            self.vPrest.export(outfile, level, namespace_, name_='vPrest', pretty_print=pretty_print)
        if self.imp is not None:
            self.imp.export(outfile, level, namespace_, name_='imp', pretty_print=pretty_print)
        if self.infCTeNorm is not None:
            self.infCTeNorm.export(outfile, level, namespace_, name_='infCTeNorm', pretty_print=pretty_print)
        if self.infCteComp is not None:
            self.infCteComp.export(outfile, level, namespace_, name_='infCteComp', pretty_print=pretty_print)
        if self.infCteAnu is not None:
            self.infCteAnu.export(outfile, level, namespace_, name_='infCteAnu', pretty_print=pretty_print)
        for autXML_ in self.autXML:
            autXML_.export(outfile, level, namespace_, name_='autXML', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('versao', node)
        if value is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            self.versao = value
            self.validate_TVerCTe(self.versao)    # validate type TVerCTe
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ide':
            obj_ = ide.factory()
            obj_.build(child_)
            self.ide = obj_
            obj_.original_tagname_ = 'ide'
        elif nodeName_ == 'compl':
            obj_ = compl.factory()
            obj_.build(child_)
            self.compl = obj_
            obj_.original_tagname_ = 'compl'
        elif nodeName_ == 'emit':
            obj_ = emit.factory()
            obj_.build(child_)
            self.emit = obj_
            obj_.original_tagname_ = 'emit'
        elif nodeName_ == 'rem':
            obj_ = rem.factory()
            obj_.build(child_)
            self.rem = obj_
            obj_.original_tagname_ = 'rem'
        elif nodeName_ == 'exped':
            obj_ = exped.factory()
            obj_.build(child_)
            self.exped = obj_
            obj_.original_tagname_ = 'exped'
        elif nodeName_ == 'receb':
            obj_ = receb.factory()
            obj_.build(child_)
            self.receb = obj_
            obj_.original_tagname_ = 'receb'
        elif nodeName_ == 'dest':
            obj_ = dest.factory()
            obj_.build(child_)
            self.dest = obj_
            obj_.original_tagname_ = 'dest'
        elif nodeName_ == 'vPrest':
            obj_ = vPrest.factory()
            obj_.build(child_)
            self.vPrest = obj_
            obj_.original_tagname_ = 'vPrest'
        elif nodeName_ == 'imp':
            obj_ = imp.factory()
            obj_.build(child_)
            self.imp = obj_
            obj_.original_tagname_ = 'imp'
        elif nodeName_ == 'infCTeNorm':
            obj_ = infCTeNorm.factory()
            obj_.build(child_)
            self.infCTeNorm = obj_
            obj_.original_tagname_ = 'infCTeNorm'
        elif nodeName_ == 'infCteComp':
            obj_ = infCteComp.factory()
            obj_.build(child_)
            self.infCteComp = obj_
            obj_.original_tagname_ = 'infCteComp'
        elif nodeName_ == 'infCteAnu':
            obj_ = infCteAnu.factory()
            obj_.build(child_)
            self.infCteAnu = obj_
            obj_.original_tagname_ = 'infCteAnu'
        elif nodeName_ == 'autXML':
            obj_ = autXML.factory()
            obj_.build(child_)
            self.autXML.append(obj_)
            obj_.original_tagname_ = 'autXML'
# end class infCte


class ide(GeneratedsSuper):
    """Identificação do CT-eInformar apenas para tpEmis diferente de 1"""
    subclass = None
    superclass = None
    def __init__(self, cUF=None, cCT=None, CFOP=None, natOp=None, mod=None, serie=None, nCT=None, dhEmi=None, tpImp=None, tpEmis=None, cDV=None, tpAmb=None, tpCTe=None, procEmi=None, verProc=None, indGlobalizado=None, cMunEnv=None, xMunEnv=None, UFEnv=None, modal=None, tpServ=None, cMunIni=None, xMunIni=None, UFIni=None, cMunFim=None, xMunFim=None, UFFim=None, retira=None, xDetRetira=None, indIEToma=None, toma3=None, toma4=None, dhCont=None, xJust=None):
        self.original_tagname_ = None
        self.cUF = cUF
        self.cCT = cCT
        self.CFOP = CFOP
        self.validate_TCfop(self.CFOP)
        self.natOp = natOp
        self.mod = mod
        self.serie = serie
        self.nCT = nCT
        self.dhEmi = dhEmi
        self.tpImp = tpImp
        self.tpEmis = tpEmis
        self.cDV = cDV
        self.tpAmb = tpAmb
        self.tpCTe = tpCTe
        self.validate_TFinCTe(self.tpCTe)
        self.procEmi = procEmi
        self.validate_TProcEmi(self.procEmi)
        self.verProc = verProc
        self.indGlobalizado = indGlobalizado
        self.cMunEnv = cMunEnv
        self.xMunEnv = xMunEnv
        self.UFEnv = UFEnv
        self.modal = modal
        self.validate_TModTransp(self.modal)
        self.tpServ = tpServ
        self.cMunIni = cMunIni
        self.xMunIni = xMunIni
        self.UFIni = UFIni
        self.cMunFim = cMunFim
        self.xMunFim = xMunFim
        self.UFFim = UFFim
        self.retira = retira
        self.xDetRetira = xDetRetira
        self.indIEToma = indIEToma
        self.toma3 = toma3
        self.toma4 = toma4
        self.dhCont = dhCont
        self.xJust = xJust
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ide)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ide.subclass:
            return ide.subclass(*args_, **kwargs_)
        else:
            return ide(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cUF(self): return self.cUF
    def set_cUF(self, cUF): self.cUF = cUF
    def get_cCT(self): return self.cCT
    def set_cCT(self, cCT): self.cCT = cCT
    def get_CFOP(self): return self.CFOP
    def set_CFOP(self, CFOP): self.CFOP = CFOP
    def get_natOp(self): return self.natOp
    def set_natOp(self, natOp): self.natOp = natOp
    def get_mod(self): return self.mod
    def set_mod(self, mod): self.mod = mod
    def get_serie(self): return self.serie
    def set_serie(self, serie): self.serie = serie
    def get_nCT(self): return self.nCT
    def set_nCT(self, nCT): self.nCT = nCT
    def get_dhEmi(self): return self.dhEmi
    def set_dhEmi(self, dhEmi): self.dhEmi = dhEmi
    def get_tpImp(self): return self.tpImp
    def set_tpImp(self, tpImp): self.tpImp = tpImp
    def get_tpEmis(self): return self.tpEmis
    def set_tpEmis(self, tpEmis): self.tpEmis = tpEmis
    def get_cDV(self): return self.cDV
    def set_cDV(self, cDV): self.cDV = cDV
    def get_tpAmb(self): return self.tpAmb
    def set_tpAmb(self, tpAmb): self.tpAmb = tpAmb
    def get_tpCTe(self): return self.tpCTe
    def set_tpCTe(self, tpCTe): self.tpCTe = tpCTe
    def get_procEmi(self): return self.procEmi
    def set_procEmi(self, procEmi): self.procEmi = procEmi
    def get_verProc(self): return self.verProc
    def set_verProc(self, verProc): self.verProc = verProc
    def get_indGlobalizado(self): return self.indGlobalizado
    def set_indGlobalizado(self, indGlobalizado): self.indGlobalizado = indGlobalizado
    def get_cMunEnv(self): return self.cMunEnv
    def set_cMunEnv(self, cMunEnv): self.cMunEnv = cMunEnv
    def get_xMunEnv(self): return self.xMunEnv
    def set_xMunEnv(self, xMunEnv): self.xMunEnv = xMunEnv
    def get_UFEnv(self): return self.UFEnv
    def set_UFEnv(self, UFEnv): self.UFEnv = UFEnv
    def get_modal(self): return self.modal
    def set_modal(self, modal): self.modal = modal
    def get_tpServ(self): return self.tpServ
    def set_tpServ(self, tpServ): self.tpServ = tpServ
    def get_cMunIni(self): return self.cMunIni
    def set_cMunIni(self, cMunIni): self.cMunIni = cMunIni
    def get_xMunIni(self): return self.xMunIni
    def set_xMunIni(self, xMunIni): self.xMunIni = xMunIni
    def get_UFIni(self): return self.UFIni
    def set_UFIni(self, UFIni): self.UFIni = UFIni
    def get_cMunFim(self): return self.cMunFim
    def set_cMunFim(self, cMunFim): self.cMunFim = cMunFim
    def get_xMunFim(self): return self.xMunFim
    def set_xMunFim(self, xMunFim): self.xMunFim = xMunFim
    def get_UFFim(self): return self.UFFim
    def set_UFFim(self, UFFim): self.UFFim = UFFim
    def get_retira(self): return self.retira
    def set_retira(self, retira): self.retira = retira
    def get_xDetRetira(self): return self.xDetRetira
    def set_xDetRetira(self, xDetRetira): self.xDetRetira = xDetRetira
    def get_indIEToma(self): return self.indIEToma
    def set_indIEToma(self, indIEToma): self.indIEToma = indIEToma
    def get_toma3(self): return self.toma3
    def set_toma3(self, toma3): self.toma3 = toma3
    def get_toma4(self): return self.toma4
    def set_toma4(self, toma4): self.toma4 = toma4
    def get_dhCont(self): return self.dhCont
    def set_dhCont(self, dhCont): self.dhCont = dhCont
    def get_xJust(self): return self.xJust
    def set_xJust(self, xJust): self.xJust = xJust
    def validate_TCfop(self, value):
        # Validate type TCfop, a restriction on xs:string.
        pass
    def validate_TFinCTe(self, value):
        # Validate type TFinCTe, a restriction on xs:string.
        pass
    def validate_TProcEmi(self, value):
        # Validate type TProcEmi, a restriction on xs:string.
        pass
    def validate_TModTransp(self, value):
        # Validate type TModTransp, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.cUF is not None or
            self.cCT is not None or
            self.CFOP is not None or
            self.natOp is not None or
            self.mod is not None or
            self.serie is not None or
            self.nCT is not None or
            self.dhEmi is not None or
            self.tpImp is not None or
            self.tpEmis is not None or
            self.cDV is not None or
            self.tpAmb is not None or
            self.tpCTe is not None or
            self.procEmi is not None or
            self.verProc is not None or
            self.indGlobalizado is not None or
            self.cMunEnv is not None or
            self.xMunEnv is not None or
            self.UFEnv is not None or
            self.modal is not None or
            self.tpServ is not None or
            self.cMunIni is not None or
            self.xMunIni is not None or
            self.UFIni is not None or
            self.cMunFim is not None or
            self.xMunFim is not None or
            self.UFFim is not None or
            self.retira is not None or
            self.xDetRetira is not None or
            self.indIEToma is not None or
            self.toma3 is not None or
            self.toma4 is not None or
            self.dhCont is not None or
            self.xJust is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ide', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ide')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ide')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ide', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ide'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ide', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cUF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scUF>%s</%scUF>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.cUF), input_name='cUF')), namespace_, eol_))
        if self.cCT is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scCT>%s</%scCT>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.cCT), input_name='cCT')), namespace_, eol_))
        if self.CFOP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCFOP>%s</%sCFOP>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CFOP), input_name='CFOP')), namespace_, eol_))
        if self.natOp is not None:
            self.natOp.export(outfile, level, namespace_, name_='natOp', pretty_print=pretty_print)
        if self.mod is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smod>%s</%smod>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.mod), input_name='mod')), namespace_, eol_))
        if self.serie is not None:
            self.serie.export(outfile, level, namespace_, name_='serie', pretty_print=pretty_print)
        if self.nCT is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snCT>%s</%snCT>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.nCT), input_name='nCT')), namespace_, eol_))
        if self.dhEmi is not None:
            self.dhEmi.export(outfile, level, namespace_, name_='dhEmi', pretty_print=pretty_print)
        if self.tpImp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpImp>%s</%stpImp>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.tpImp), input_name='tpImp')), namespace_, eol_))
        if self.tpEmis is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpEmis>%s</%stpEmis>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.tpEmis), input_name='tpEmis')), namespace_, eol_))
        if self.cDV is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scDV>%s</%scDV>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.cDV), input_name='cDV')), namespace_, eol_))
        if self.tpAmb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpAmb>%s</%stpAmb>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.tpAmb), input_name='tpAmb')), namespace_, eol_))
        if self.tpCTe is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpCTe>%s</%stpCTe>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.tpCTe), input_name='tpCTe')), namespace_, eol_))
        if self.procEmi is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprocEmi>%s</%sprocEmi>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.procEmi), input_name='procEmi')), namespace_, eol_))
        if self.verProc is not None:
            self.verProc.export(outfile, level, namespace_, name_='verProc', pretty_print=pretty_print)
        if self.indGlobalizado is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sindGlobalizado>%s</%sindGlobalizado>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.indGlobalizado), input_name='indGlobalizado')), namespace_, eol_))
        if self.cMunEnv is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scMunEnv>%s</%scMunEnv>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.cMunEnv), input_name='cMunEnv')), namespace_, eol_))
        if self.xMunEnv is not None:
            self.xMunEnv.export(outfile, level, namespace_, name_='xMunEnv', pretty_print=pretty_print)
        if self.UFEnv is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUFEnv>%s</%sUFEnv>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.UFEnv), input_name='UFEnv')), namespace_, eol_))
        if self.modal is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smodal>%s</%smodal>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.modal), input_name='modal')), namespace_, eol_))
        if self.tpServ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpServ>%s</%stpServ>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.tpServ), input_name='tpServ')), namespace_, eol_))
        if self.cMunIni is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scMunIni>%s</%scMunIni>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.cMunIni), input_name='cMunIni')), namespace_, eol_))
        if self.xMunIni is not None:
            self.xMunIni.export(outfile, level, namespace_, name_='xMunIni', pretty_print=pretty_print)
        if self.UFIni is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUFIni>%s</%sUFIni>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.UFIni), input_name='UFIni')), namespace_, eol_))
        if self.cMunFim is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scMunFim>%s</%scMunFim>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.cMunFim), input_name='cMunFim')), namespace_, eol_))
        if self.xMunFim is not None:
            self.xMunFim.export(outfile, level, namespace_, name_='xMunFim', pretty_print=pretty_print)
        if self.UFFim is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUFFim>%s</%sUFFim>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.UFFim), input_name='UFFim')), namespace_, eol_))
        if self.retira is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sretira>%s</%sretira>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.retira), input_name='retira')), namespace_, eol_))
        if self.xDetRetira is not None:
            self.xDetRetira.export(outfile, level, namespace_, name_='xDetRetira', pretty_print=pretty_print)
        if self.indIEToma is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sindIEToma>%s</%sindIEToma>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.indIEToma), input_name='indIEToma')), namespace_, eol_))
        if self.toma3 is not None:
            self.toma3.export(outfile, level, namespace_, name_='toma3', pretty_print=pretty_print)
        if self.toma4 is not None:
            self.toma4.export(outfile, level, namespace_, name_='toma4', pretty_print=pretty_print)
        if self.dhCont is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdhCont>%s</%sdhCont>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.dhCont), input_name='dhCont')), namespace_, eol_))
        if self.xJust is not None:
            self.xJust.export(outfile, level, namespace_, name_='xJust', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cUF':
            cUF_ = child_.text
            cUF_ = self.gds_validate_string(cUF_, node, 'cUF')
            self.cUF = cUF_
        elif nodeName_ == 'cCT':
            cCT_ = child_.text
            cCT_ = self.gds_validate_string(cCT_, node, 'cCT')
            self.cCT = cCT_
        elif nodeName_ == 'CFOP':
            CFOP_ = child_.text
            CFOP_ = self.gds_validate_string(CFOP_, node, 'CFOP')
            self.CFOP = CFOP_
            # validate type TCfop
            self.validate_TCfop(self.CFOP)
        elif nodeName_ == 'natOp':
            obj_ = None
            self.natOp = obj_
            obj_.original_tagname_ = 'natOp'
        elif nodeName_ == 'mod':
            mod_ = child_.text
            mod_ = self.gds_validate_string(mod_, node, 'mod')
            self.mod = mod_
        elif nodeName_ == 'serie':
            obj_ = None
            self.serie = obj_
            obj_.original_tagname_ = 'serie'
        elif nodeName_ == 'nCT':
            nCT_ = child_.text
            nCT_ = self.gds_validate_string(nCT_, node, 'nCT')
            self.nCT = nCT_
        elif nodeName_ == 'dhEmi':
            obj_ = None
            self.dhEmi = obj_
            obj_.original_tagname_ = 'dhEmi'
        elif nodeName_ == 'tpImp':
            tpImp_ = child_.text
            tpImp_ = self.gds_validate_string(tpImp_, node, 'tpImp')
            self.tpImp = tpImp_
        elif nodeName_ == 'tpEmis':
            tpEmis_ = child_.text
            tpEmis_ = self.gds_validate_string(tpEmis_, node, 'tpEmis')
            self.tpEmis = tpEmis_
        elif nodeName_ == 'cDV':
            cDV_ = child_.text
            cDV_ = self.gds_validate_string(cDV_, node, 'cDV')
            self.cDV = cDV_
        elif nodeName_ == 'tpAmb':
            tpAmb_ = child_.text
            tpAmb_ = self.gds_validate_string(tpAmb_, node, 'tpAmb')
            self.tpAmb = tpAmb_
        elif nodeName_ == 'tpCTe':
            tpCTe_ = child_.text
            tpCTe_ = self.gds_validate_string(tpCTe_, node, 'tpCTe')
            self.tpCTe = tpCTe_
            # validate type TFinCTe
            self.validate_TFinCTe(self.tpCTe)
        elif nodeName_ == 'procEmi':
            procEmi_ = child_.text
            procEmi_ = self.gds_validate_string(procEmi_, node, 'procEmi')
            self.procEmi = procEmi_
            # validate type TProcEmi
            self.validate_TProcEmi(self.procEmi)
        elif nodeName_ == 'verProc':
            obj_ = None
            self.verProc = obj_
            obj_.original_tagname_ = 'verProc'
        elif nodeName_ == 'indGlobalizado':
            indGlobalizado_ = child_.text
            indGlobalizado_ = self.gds_validate_string(indGlobalizado_, node, 'indGlobalizado')
            self.indGlobalizado = indGlobalizado_
        elif nodeName_ == 'cMunEnv':
            cMunEnv_ = child_.text
            cMunEnv_ = self.gds_validate_string(cMunEnv_, node, 'cMunEnv')
            self.cMunEnv = cMunEnv_
        elif nodeName_ == 'xMunEnv':
            obj_ = None
            self.xMunEnv = obj_
            obj_.original_tagname_ = 'xMunEnv'
        elif nodeName_ == 'UFEnv':
            UFEnv_ = child_.text
            UFEnv_ = self.gds_validate_string(UFEnv_, node, 'UFEnv')
            self.UFEnv = UFEnv_
        elif nodeName_ == 'modal':
            modal_ = child_.text
            modal_ = self.gds_validate_string(modal_, node, 'modal')
            self.modal = modal_
            # validate type TModTransp
            self.validate_TModTransp(self.modal)
        elif nodeName_ == 'tpServ':
            tpServ_ = child_.text
            tpServ_ = self.gds_validate_string(tpServ_, node, 'tpServ')
            self.tpServ = tpServ_
        elif nodeName_ == 'cMunIni':
            cMunIni_ = child_.text
            cMunIni_ = self.gds_validate_string(cMunIni_, node, 'cMunIni')
            self.cMunIni = cMunIni_
        elif nodeName_ == 'xMunIni':
            obj_ = None
            self.xMunIni = obj_
            obj_.original_tagname_ = 'xMunIni'
        elif nodeName_ == 'UFIni':
            UFIni_ = child_.text
            UFIni_ = self.gds_validate_string(UFIni_, node, 'UFIni')
            self.UFIni = UFIni_
        elif nodeName_ == 'cMunFim':
            cMunFim_ = child_.text
            cMunFim_ = self.gds_validate_string(cMunFim_, node, 'cMunFim')
            self.cMunFim = cMunFim_
        elif nodeName_ == 'xMunFim':
            obj_ = None
            self.xMunFim = obj_
            obj_.original_tagname_ = 'xMunFim'
        elif nodeName_ == 'UFFim':
            UFFim_ = child_.text
            UFFim_ = self.gds_validate_string(UFFim_, node, 'UFFim')
            self.UFFim = UFFim_
        elif nodeName_ == 'retira':
            retira_ = child_.text
            retira_ = self.gds_validate_string(retira_, node, 'retira')
            self.retira = retira_
        elif nodeName_ == 'xDetRetira':
            obj_ = None
            self.xDetRetira = obj_
            obj_.original_tagname_ = 'xDetRetira'
        elif nodeName_ == 'indIEToma':
            indIEToma_ = child_.text
            indIEToma_ = self.gds_validate_string(indIEToma_, node, 'indIEToma')
            self.indIEToma = indIEToma_
        elif nodeName_ == 'toma3':
            obj_ = toma3.factory()
            obj_.build(child_)
            self.toma3 = obj_
            obj_.original_tagname_ = 'toma3'
        elif nodeName_ == 'toma4':
            obj_ = toma4.factory()
            obj_.build(child_)
            self.toma4 = obj_
            obj_.original_tagname_ = 'toma4'
        elif nodeName_ == 'dhCont':
            dhCont_ = child_.text
            dhCont_ = self.gds_validate_string(dhCont_, node, 'dhCont')
            self.dhCont = dhCont_
        elif nodeName_ == 'xJust':
            obj_ = None
            self.xJust = obj_
            obj_.original_tagname_ = 'xJust'
# end class ide


class cCT(GeneratedsSuper):
    """Código numérico que compõe a Chave de Acesso. Número aleatório
    gerado pelo emitente para cada CT-e, com o objetivo de evitar
    acessos indevidos ao documento."""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cCT)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cCT.subclass:
            return cCT.subclass(*args_, **kwargs_)
        else:
            return cCT(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cCT', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cCT')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cCT')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='cCT', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cCT'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='cCT', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cCT


class natOp(GeneratedsSuper):
    """Natureza da Operação"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, natOp)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if natOp.subclass:
            return natOp.subclass(*args_, **kwargs_)
        else:
            return natOp(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='natOp', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('natOp')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='natOp')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='natOp', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='natOp'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='natOp', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class natOp


class serie(GeneratedsSuper):
    """Série do CT-ePreencher com "0" no caso de série única"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, serie)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if serie.subclass:
            return serie.subclass(*args_, **kwargs_)
        else:
            return serie(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='serie', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('serie')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='serie')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='serie', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='serie'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='serie', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class serie


class dhEmi(GeneratedsSuper):
    """Data e hora de emissão do CT-eFormato AAAA-MM-DDTHH:MM:DD TZD"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, dhEmi)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if dhEmi.subclass:
            return dhEmi.subclass(*args_, **kwargs_)
        else:
            return dhEmi(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='dhEmi', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('dhEmi')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='dhEmi')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='dhEmi', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='dhEmi'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='dhEmi', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class dhEmi


class tpImp(GeneratedsSuper):
    """Formato de impressão do DACTEPreencher com: 1 - Retrato; 2 -
    Paisagem."""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpImp)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpImp.subclass:
            return tpImp.subclass(*args_, **kwargs_)
        else:
            return tpImp(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='tpImp', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpImp')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tpImp')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='tpImp', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='tpImp'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='tpImp', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class tpImp


class tpEmis(GeneratedsSuper):
    """Forma de emissão do CT-e Preencher com: 1 - Normal; 4-EPEC pela SVC;
    5 - Contingência FSDA; 7 - Autorização pela SVC-RS; 8 -
    Autorização pela SVC-SP"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpEmis)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpEmis.subclass:
            return tpEmis.subclass(*args_, **kwargs_)
        else:
            return tpEmis(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='tpEmis', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpEmis')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tpEmis')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='tpEmis', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='tpEmis'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='tpEmis', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class tpEmis


class cDV(GeneratedsSuper):
    """Digito Verificador da chave de acesso do CT-eInformar o dígito de
    controle da chave de acesso do CT-e, que deve ser calculado com
    a aplicação do algoritmo módulo 11 (base 2,9) da chave de
    acesso."""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cDV)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cDV.subclass:
            return cDV.subclass(*args_, **kwargs_)
        else:
            return cDV(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cDV', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cDV')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cDV')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='cDV', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cDV'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='cDV', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cDV


class verProc(GeneratedsSuper):
    """Versão do processo de emissãoIinformar a versão do aplicativo
    emissor de CT-e."""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, verProc)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if verProc.subclass:
            return verProc.subclass(*args_, **kwargs_)
        else:
            return verProc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='verProc', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('verProc')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='verProc')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='verProc', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='verProc'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='verProc', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class verProc


class indGlobalizado(GeneratedsSuper):
    """Indicador de CT-e GlobalizadoInformar valor 1 quando for Globalizado
    e não informar a tag quando não tratar de CT-e Globalizado"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, indGlobalizado)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if indGlobalizado.subclass:
            return indGlobalizado.subclass(*args_, **kwargs_)
        else:
            return indGlobalizado(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='indGlobalizado', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('indGlobalizado')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='indGlobalizado')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='indGlobalizado', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='indGlobalizado'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='indGlobalizado', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class indGlobalizado


class xMunEnv(GeneratedsSuper):
    """Nome do Município de envio do CT-e (de onde o documento foi
    transmitido)Informar PAIS/Municipio para as operações com o
    exterior."""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, xMunEnv)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if xMunEnv.subclass:
            return xMunEnv.subclass(*args_, **kwargs_)
        else:
            return xMunEnv(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='xMunEnv', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('xMunEnv')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='xMunEnv')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='xMunEnv', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='xMunEnv'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='xMunEnv', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class xMunEnv


class tpServ(GeneratedsSuper):
    """Tipo do ServiçoPreencher com: 0 - Normal;1 - Subcontratação; 2 -
    Redespacho;3 - Redespacho Intermediário; 4 - Serviço Vinculado a
    Multimodal"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpServ)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpServ.subclass:
            return tpServ.subclass(*args_, **kwargs_)
        else:
            return tpServ(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='tpServ', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpServ')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tpServ')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='tpServ', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='tpServ'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='tpServ', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class tpServ


class xMunIni(GeneratedsSuper):
    """Nome do Município do início da prestaçãoInformar 'EXTERIOR' para
    operações com o exterior."""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, xMunIni)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if xMunIni.subclass:
            return xMunIni.subclass(*args_, **kwargs_)
        else:
            return xMunIni(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='xMunIni', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('xMunIni')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='xMunIni')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='xMunIni', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='xMunIni'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='xMunIni', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class xMunIni


class xMunFim(GeneratedsSuper):
    """Nome do Município do término da prestaçãoInformar 'EXTERIOR' para
    operações com o exterior."""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, xMunFim)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if xMunFim.subclass:
            return xMunFim.subclass(*args_, **kwargs_)
        else:
            return xMunFim(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='xMunFim', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('xMunFim')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='xMunFim')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='xMunFim', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='xMunFim'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='xMunFim', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class xMunFim


class retira(GeneratedsSuper):
    """Indicador se o Recebedor retira no Aeroporto, Filial, Porto ou
    Estação de Destino?Preencher com: 0 - sim; 1 - não"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, retira)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if retira.subclass:
            return retira.subclass(*args_, **kwargs_)
        else:
            return retira(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='retira', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('retira')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='retira')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='retira', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='retira'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='retira', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class retira


class xDetRetira(GeneratedsSuper):
    """Detalhes do retira"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, xDetRetira)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if xDetRetira.subclass:
            return xDetRetira.subclass(*args_, **kwargs_)
        else:
            return xDetRetira(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='xDetRetira', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('xDetRetira')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='xDetRetira')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='xDetRetira', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='xDetRetira'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='xDetRetira', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class xDetRetira


class indIEToma(GeneratedsSuper):
    """Indicador do papel do tomador na prestação do serviço: 1 –
    Contribuinte ICMS; 2 – Contribuinte isento de inscrição; 9 – Não
    ContribuinteAplica-se ao tomador que for indicado no toma3 ou
    toma4"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, indIEToma)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if indIEToma.subclass:
            return indIEToma.subclass(*args_, **kwargs_)
        else:
            return indIEToma(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='indIEToma', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('indIEToma')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='indIEToma')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='indIEToma', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='indIEToma'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='indIEToma', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class indIEToma


class toma3(GeneratedsSuper):
    """Indicador do "papel" do tomador do serviço no CT-e"""
    subclass = None
    superclass = None
    def __init__(self, toma=None):
        self.original_tagname_ = None
        self.toma = toma
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, toma3)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if toma3.subclass:
            return toma3.subclass(*args_, **kwargs_)
        else:
            return toma3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_toma(self): return self.toma
    def set_toma(self, toma): self.toma = toma
    def hasContent_(self):
        if (
            self.toma is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='toma3', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('toma3')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='toma3')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='toma3', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='toma3'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='toma3', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.toma is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stoma>%s</%stoma>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.toma), input_name='toma')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'toma':
            toma_ = child_.text
            toma_ = self.gds_validate_string(toma_, node, 'toma')
            self.toma = toma_
# end class toma3


class toma(GeneratedsSuper):
    """Tomador do ServiçoPreencher com: 0-Remetente; 1-Expedidor;
    2-Recebedor; 3-Destinatário Serão utilizadas as informações
    contidas no respectivo grupo, conforme indicado pelo conteúdo
    deste campo"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, toma)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if toma.subclass:
            return toma.subclass(*args_, **kwargs_)
        else:
            return toma(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='toma', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('toma')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='toma')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='toma', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='toma'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='toma', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class toma


class toma4(GeneratedsSuper):
    """Indicador do "papel" do tomador do serviço no CT-e"""
    subclass = None
    superclass = None
    def __init__(self, toma=None, CNPJ=None, CPF=None, IE=None, xNome=None, xFant=None, fone=None, enderToma=None, email=None):
        self.original_tagname_ = None
        self.toma = toma
        self.CNPJ = CNPJ
        self.CPF = CPF
        self.IE = IE
        self.xNome = xNome
        self.xFant = xFant
        self.fone = fone
        self.enderToma = enderToma
        self.email = email
        self.validate_TEmail(self.email)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, toma4)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if toma4.subclass:
            return toma4.subclass(*args_, **kwargs_)
        else:
            return toma4(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_toma(self): return self.toma
    def set_toma(self, toma): self.toma = toma
    def get_CNPJ(self): return self.CNPJ
    def set_CNPJ(self, CNPJ): self.CNPJ = CNPJ
    def get_CPF(self): return self.CPF
    def set_CPF(self, CPF): self.CPF = CPF
    def get_IE(self): return self.IE
    def set_IE(self, IE): self.IE = IE
    def get_xNome(self): return self.xNome
    def set_xNome(self, xNome): self.xNome = xNome
    def get_xFant(self): return self.xFant
    def set_xFant(self, xFant): self.xFant = xFant
    def get_fone(self): return self.fone
    def set_fone(self, fone): self.fone = fone
    def get_enderToma(self): return self.enderToma
    def set_enderToma(self, enderToma): self.enderToma = enderToma
    def get_email(self): return self.email
    def set_email(self, email): self.email = email
    def validate_TEmail(self, value):
        # Validate type TEmail, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.toma is not None or
            self.CNPJ is not None or
            self.CPF is not None or
            self.IE is not None or
            self.xNome is not None or
            self.xFant is not None or
            self.fone is not None or
            self.enderToma is not None or
            self.email is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='toma4', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('toma4')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='toma4')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='toma4', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='toma4'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='toma4', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.toma is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stoma>%s</%stoma>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.toma), input_name='toma')), namespace_, eol_))
        if self.CNPJ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCNPJ>%s</%sCNPJ>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CNPJ), input_name='CNPJ')), namespace_, eol_))
        if self.CPF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCPF>%s</%sCPF>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CPF), input_name='CPF')), namespace_, eol_))
        if self.IE is not None:
            self.IE.export(outfile, level, namespace_, name_='IE', pretty_print=pretty_print)
        if self.xNome is not None:
            self.xNome.export(outfile, level, namespace_, name_='xNome', pretty_print=pretty_print)
        if self.xFant is not None:
            self.xFant.export(outfile, level, namespace_, name_='xFant', pretty_print=pretty_print)
        if self.fone is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfone>%s</%sfone>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.fone), input_name='fone')), namespace_, eol_))
        if self.enderToma is not None:
            self.enderToma.export(outfile, level, namespace_, name_='enderToma', pretty_print=pretty_print)
        if self.email is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%semail>%s</%semail>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.email), input_name='email')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'toma':
            toma_ = child_.text
            toma_ = self.gds_validate_string(toma_, node, 'toma')
            self.toma = toma_
        elif nodeName_ == 'CNPJ':
            CNPJ_ = child_.text
            CNPJ_ = self.gds_validate_string(CNPJ_, node, 'CNPJ')
            self.CNPJ = CNPJ_
        elif nodeName_ == 'CPF':
            CPF_ = child_.text
            CPF_ = self.gds_validate_string(CPF_, node, 'CPF')
            self.CPF = CPF_
        elif nodeName_ == 'IE':
            obj_ = None
            self.IE = obj_
            obj_.original_tagname_ = 'IE'
        elif nodeName_ == 'xNome':
            obj_ = None
            self.xNome = obj_
            obj_.original_tagname_ = 'xNome'
        elif nodeName_ == 'xFant':
            obj_ = None
            self.xFant = obj_
            obj_.original_tagname_ = 'xFant'
        elif nodeName_ == 'fone':
            fone_ = child_.text
            fone_ = self.gds_validate_string(fone_, node, 'fone')
            self.fone = fone_
        elif nodeName_ == 'enderToma':
            obj_ = TEndereco.factory()
            obj_.build(child_)
            self.enderToma = obj_
            obj_.original_tagname_ = 'enderToma'
        elif nodeName_ == 'email':
            email_ = child_.text
            email_ = self.gds_validate_string(email_, node, 'email')
            self.email = email_
            # validate type TEmail
            self.validate_TEmail(self.email)
# end class toma4


class IE(GeneratedsSuper):
    """Inscrição EstadualInformar a IE do tomador ou ISENTO se tomador é
    contribuinte do ICMS isento de inscrição no cadastro de
    contribuintes do ICMS. Caso o tomador não seja contribuinte do
    ICMS não informar o conteúdo."""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IE.subclass:
            return IE.subclass(*args_, **kwargs_)
        else:
            return IE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IE', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IE')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IE')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IE', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IE'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='IE', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class IE


class xNome(GeneratedsSuper):
    """Razão Social ou Nome"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, xNome)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if xNome.subclass:
            return xNome.subclass(*args_, **kwargs_)
        else:
            return xNome(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='xNome', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('xNome')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='xNome')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='xNome', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='xNome'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='xNome', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class xNome


class xFant(GeneratedsSuper):
    """Nome Fantasia"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, xFant)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if xFant.subclass:
            return xFant.subclass(*args_, **kwargs_)
        else:
            return xFant(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='xFant', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('xFant')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='xFant')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='xFant', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='xFant'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='xFant', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class xFant


class xJust(GeneratedsSuper):
    """Justificativa da entrada em contingência"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, xJust)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if xJust.subclass:
            return xJust.subclass(*args_, **kwargs_)
        else:
            return xJust(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='xJust', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('xJust')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='xJust')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='xJust', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='xJust'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='xJust', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class xJust


class compl(GeneratedsSuper):
    """Dados complementares do CT-e para fins operacionais ou comerciais"""
    subclass = None
    superclass = None
    def __init__(self, xCaracAd=None, xCaracSer=None, xEmi=None, fluxo=None, Entrega=None, origCalc=None, destCalc=None, xObs=None, ObsCont=None, ObsFisco=None):
        self.original_tagname_ = None
        self.xCaracAd = xCaracAd
        self.xCaracSer = xCaracSer
        self.xEmi = xEmi
        self.fluxo = fluxo
        self.Entrega = Entrega
        self.origCalc = origCalc
        self.destCalc = destCalc
        self.xObs = xObs
        if ObsCont is None:
            self.ObsCont = []
        else:
            self.ObsCont = ObsCont
        if ObsFisco is None:
            self.ObsFisco = []
        else:
            self.ObsFisco = ObsFisco
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, compl)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if compl.subclass:
            return compl.subclass(*args_, **kwargs_)
        else:
            return compl(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_xCaracAd(self): return self.xCaracAd
    def set_xCaracAd(self, xCaracAd): self.xCaracAd = xCaracAd
    def get_xCaracSer(self): return self.xCaracSer
    def set_xCaracSer(self, xCaracSer): self.xCaracSer = xCaracSer
    def get_xEmi(self): return self.xEmi
    def set_xEmi(self, xEmi): self.xEmi = xEmi
    def get_fluxo(self): return self.fluxo
    def set_fluxo(self, fluxo): self.fluxo = fluxo
    def get_Entrega(self): return self.Entrega
    def set_Entrega(self, Entrega): self.Entrega = Entrega
    def get_origCalc(self): return self.origCalc
    def set_origCalc(self, origCalc): self.origCalc = origCalc
    def get_destCalc(self): return self.destCalc
    def set_destCalc(self, destCalc): self.destCalc = destCalc
    def get_xObs(self): return self.xObs
    def set_xObs(self, xObs): self.xObs = xObs
    def get_ObsCont(self): return self.ObsCont
    def set_ObsCont(self, ObsCont): self.ObsCont = ObsCont
    def add_ObsCont(self, value): self.ObsCont.append(value)
    def insert_ObsCont_at(self, index, value): self.ObsCont.insert(index, value)
    def replace_ObsCont_at(self, index, value): self.ObsCont[index] = value
    def get_ObsFisco(self): return self.ObsFisco
    def set_ObsFisco(self, ObsFisco): self.ObsFisco = ObsFisco
    def add_ObsFisco(self, value): self.ObsFisco.append(value)
    def insert_ObsFisco_at(self, index, value): self.ObsFisco.insert(index, value)
    def replace_ObsFisco_at(self, index, value): self.ObsFisco[index] = value
    def hasContent_(self):
        if (
            self.xCaracAd is not None or
            self.xCaracSer is not None or
            self.xEmi is not None or
            self.fluxo is not None or
            self.Entrega is not None or
            self.origCalc is not None or
            self.destCalc is not None or
            self.xObs is not None or
            self.ObsCont or
            self.ObsFisco
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='compl', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('compl')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='compl')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='compl', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='compl'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='compl', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.xCaracAd is not None:
            self.xCaracAd.export(outfile, level, namespace_, name_='xCaracAd', pretty_print=pretty_print)
        if self.xCaracSer is not None:
            self.xCaracSer.export(outfile, level, namespace_, name_='xCaracSer', pretty_print=pretty_print)
        if self.xEmi is not None:
            self.xEmi.export(outfile, level, namespace_, name_='xEmi', pretty_print=pretty_print)
        if self.fluxo is not None:
            self.fluxo.export(outfile, level, namespace_, name_='fluxo', pretty_print=pretty_print)
        if self.Entrega is not None:
            self.Entrega.export(outfile, level, namespace_, name_='Entrega', pretty_print=pretty_print)
        if self.origCalc is not None:
            self.origCalc.export(outfile, level, namespace_, name_='origCalc', pretty_print=pretty_print)
        if self.destCalc is not None:
            self.destCalc.export(outfile, level, namespace_, name_='destCalc', pretty_print=pretty_print)
        if self.xObs is not None:
            self.xObs.export(outfile, level, namespace_, name_='xObs', pretty_print=pretty_print)
        for ObsCont_ in self.ObsCont:
            ObsCont_.export(outfile, level, namespace_, name_='ObsCont', pretty_print=pretty_print)
        for ObsFisco_ in self.ObsFisco:
            ObsFisco_.export(outfile, level, namespace_, name_='ObsFisco', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'xCaracAd':
            obj_ = None
            self.xCaracAd = obj_
            obj_.original_tagname_ = 'xCaracAd'
        elif nodeName_ == 'xCaracSer':
            obj_ = None
            self.xCaracSer = obj_
            obj_.original_tagname_ = 'xCaracSer'
        elif nodeName_ == 'xEmi':
            obj_ = None
            self.xEmi = obj_
            obj_.original_tagname_ = 'xEmi'
        elif nodeName_ == 'fluxo':
            obj_ = fluxo.factory()
            obj_.build(child_)
            self.fluxo = obj_
            obj_.original_tagname_ = 'fluxo'
        elif nodeName_ == 'Entrega':
            obj_ = Entrega.factory()
            obj_.build(child_)
            self.Entrega = obj_
            obj_.original_tagname_ = 'Entrega'
        elif nodeName_ == 'origCalc':
            obj_ = None
            self.origCalc = obj_
            obj_.original_tagname_ = 'origCalc'
        elif nodeName_ == 'destCalc':
            obj_ = None
            self.destCalc = obj_
            obj_.original_tagname_ = 'destCalc'
        elif nodeName_ == 'xObs':
            obj_ = None
            self.xObs = obj_
            obj_.original_tagname_ = 'xObs'
        elif nodeName_ == 'ObsCont':
            obj_ = ObsCont.factory()
            obj_.build(child_)
            self.ObsCont.append(obj_)
            obj_.original_tagname_ = 'ObsCont'
        elif nodeName_ == 'ObsFisco':
            obj_ = ObsFisco.factory()
            obj_.build(child_)
            self.ObsFisco.append(obj_)
            obj_.original_tagname_ = 'ObsFisco'
# end class compl


class xCaracAd(GeneratedsSuper):
    """Característica adicional do transporteTexto livre: REENTREGA;
    DEVOLUÇÃO; REFATURAMENTO; etc"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, xCaracAd)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if xCaracAd.subclass:
            return xCaracAd.subclass(*args_, **kwargs_)
        else:
            return xCaracAd(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='xCaracAd', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('xCaracAd')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='xCaracAd')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='xCaracAd', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='xCaracAd'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='xCaracAd', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class xCaracAd


class xCaracSer(GeneratedsSuper):
    """Característica adicional do serviçoTexto livre: ENTREGA EXPRESSA;
    LOGÍSTICA REVERSA; CONVENCIONAL; EMERGENCIAL; etc"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, xCaracSer)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if xCaracSer.subclass:
            return xCaracSer.subclass(*args_, **kwargs_)
        else:
            return xCaracSer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='xCaracSer', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('xCaracSer')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='xCaracSer')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='xCaracSer', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='xCaracSer'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='xCaracSer', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class xCaracSer


class xEmi(GeneratedsSuper):
    """Funcionário emissor do CTe"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, xEmi)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if xEmi.subclass:
            return xEmi.subclass(*args_, **kwargs_)
        else:
            return xEmi(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='xEmi', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('xEmi')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='xEmi')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='xEmi', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='xEmi'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='xEmi', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class xEmi


class fluxo(GeneratedsSuper):
    """Previsão do fluxo da cargaPreenchimento obrigatório para o modal
    aéreo."""
    subclass = None
    superclass = None
    def __init__(self, xOrig=None, pass_=None, xDest=None, xRota=None):
        self.original_tagname_ = None
        self.xOrig = xOrig
        if pass_ is None:
            self.pass_ = []
        else:
            self.pass_ = pass_
        self.xDest = xDest
        self.xRota = xRota
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, fluxo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if fluxo.subclass:
            return fluxo.subclass(*args_, **kwargs_)
        else:
            return fluxo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_xOrig(self): return self.xOrig
    def set_xOrig(self, xOrig): self.xOrig = xOrig
    def get_pass(self): return self.pass_
    def set_pass(self, pass_): self.pass_ = pass_
    def add_pass(self, value): self.pass_.append(value)
    def insert_pass_at(self, index, value): self.pass_.insert(index, value)
    def replace_pass_at(self, index, value): self.pass_[index] = value
    def get_xDest(self): return self.xDest
    def set_xDest(self, xDest): self.xDest = xDest
    def get_xRota(self): return self.xRota
    def set_xRota(self, xRota): self.xRota = xRota
    def hasContent_(self):
        if (
            self.xOrig is not None or
            self.pass_ or
            self.xDest is not None or
            self.xRota is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='fluxo', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('fluxo')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='fluxo')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='fluxo', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='fluxo'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='fluxo', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.xOrig is not None:
            self.xOrig.export(outfile, level, namespace_, name_='xOrig', pretty_print=pretty_print)
        for pass_ in self.pass_:
            pass_.export(outfile, level, namespace_, name_='pass', pretty_print=pretty_print)
        if self.xDest is not None:
            self.xDest.export(outfile, level, namespace_, name_='xDest', pretty_print=pretty_print)
        if self.xRota is not None:
            self.xRota.export(outfile, level, namespace_, name_='xRota', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'xOrig':
            obj_ = None
            self.xOrig = obj_
            obj_.original_tagname_ = 'xOrig'
        elif nodeName_ == 'pass':
            obj_ = pass_.factory()
            obj_.build(child_)
            self.pass_.append(obj_)
            obj_.original_tagname_ = 'pass'
        elif nodeName_ == 'xDest':
            obj_ = None
            self.xDest = obj_
            obj_.original_tagname_ = 'xDest'
        elif nodeName_ == 'xRota':
            obj_ = None
            self.xRota = obj_
            obj_.original_tagname_ = 'xRota'
# end class fluxo


class xOrig(GeneratedsSuper):
    """Sigla ou código interno da Filial/Porto/Estação/ Aeroporto de
    OrigemObservações para o modal aéreo: - Preenchimento
    obrigatório para o modal aéreo. - O código de três letras IATA
    do aeroporto de partida deverá ser incluído como primeira
    anotação. Quando não for possível, utilizar a sigla OACI."""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, xOrig)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if xOrig.subclass:
            return xOrig.subclass(*args_, **kwargs_)
        else:
            return xOrig(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='xOrig', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('xOrig')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='xOrig')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='xOrig', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='xOrig'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='xOrig', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class xOrig


class pass_(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, xPass=None):
        self.original_tagname_ = None
        self.xPass = xPass
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, pass_)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if pass_.subclass:
            return pass_.subclass(*args_, **kwargs_)
        else:
            return pass_(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_xPass(self): return self.xPass
    def set_xPass(self, xPass): self.xPass = xPass
    def hasContent_(self):
        if (
            self.xPass is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='pass', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('pass')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='pass')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='pass', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='pass'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='pass', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.xPass is not None:
            self.xPass.export(outfile, level, namespace_, name_='xPass', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'xPass':
            obj_ = None
            self.xPass = obj_
            obj_.original_tagname_ = 'xPass'
# end class pass_


class xPass(GeneratedsSuper):
    """Sigla ou código interno da Filial/Porto/Estação/Aeroporto de
    PassagemObservação para o modal aéreo: - O código de três letras
    IATA, referente ao aeroporto de transferência, deverá ser
    incluído, quando for o caso. Quando não for possível, utilizar a
    sigla OACI. Qualquer solicitação de itinerário deverá ser
    incluída."""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, xPass)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if xPass.subclass:
            return xPass.subclass(*args_, **kwargs_)
        else:
            return xPass(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='xPass', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('xPass')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='xPass')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='xPass', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='xPass'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='xPass', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class xPass


class xDest(GeneratedsSuper):
    """Sigla ou código interno da Filial/Porto/Estação/Aeroporto de
    DestinoObservações para o modal aéreo: - Preenchimento
    obrigatório para o modal aéreo. - Deverá ser incluído o código
    de três letras IATA do aeroporto de destino. Quando não for
    possível, utilizar a sigla OACI."""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, xDest)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if xDest.subclass:
            return xDest.subclass(*args_, **kwargs_)
        else:
            return xDest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='xDest', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('xDest')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='xDest')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='xDest', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='xDest'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='xDest', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class xDest


class xRota(GeneratedsSuper):
    """Código da Rota de Entrega"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, xRota)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if xRota.subclass:
            return xRota.subclass(*args_, **kwargs_)
        else:
            return xRota(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='xRota', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('xRota')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='xRota')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='xRota', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='xRota'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='xRota', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class xRota


class Entrega(GeneratedsSuper):
    """Informações ref. a previsão de entrega"""
    subclass = None
    superclass = None
    def __init__(self, semData=None, comData=None, noPeriodo=None, semHora=None, comHora=None, noInter=None):
        self.original_tagname_ = None
        self.semData = semData
        self.comData = comData
        self.noPeriodo = noPeriodo
        self.semHora = semHora
        self.comHora = comHora
        self.noInter = noInter
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Entrega)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Entrega.subclass:
            return Entrega.subclass(*args_, **kwargs_)
        else:
            return Entrega(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_semData(self): return self.semData
    def set_semData(self, semData): self.semData = semData
    def get_comData(self): return self.comData
    def set_comData(self, comData): self.comData = comData
    def get_noPeriodo(self): return self.noPeriodo
    def set_noPeriodo(self, noPeriodo): self.noPeriodo = noPeriodo
    def get_semHora(self): return self.semHora
    def set_semHora(self, semHora): self.semHora = semHora
    def get_comHora(self): return self.comHora
    def set_comHora(self, comHora): self.comHora = comHora
    def get_noInter(self): return self.noInter
    def set_noInter(self, noInter): self.noInter = noInter
    def hasContent_(self):
        if (
            self.semData is not None or
            self.comData is not None or
            self.noPeriodo is not None or
            self.semHora is not None or
            self.comHora is not None or
            self.noInter is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Entrega', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Entrega')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Entrega')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Entrega', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Entrega'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Entrega', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.semData is not None:
            self.semData.export(outfile, level, namespace_, name_='semData', pretty_print=pretty_print)
        if self.comData is not None:
            self.comData.export(outfile, level, namespace_, name_='comData', pretty_print=pretty_print)
        if self.noPeriodo is not None:
            self.noPeriodo.export(outfile, level, namespace_, name_='noPeriodo', pretty_print=pretty_print)
        if self.semHora is not None:
            self.semHora.export(outfile, level, namespace_, name_='semHora', pretty_print=pretty_print)
        if self.comHora is not None:
            self.comHora.export(outfile, level, namespace_, name_='comHora', pretty_print=pretty_print)
        if self.noInter is not None:
            self.noInter.export(outfile, level, namespace_, name_='noInter', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'semData':
            obj_ = semData.factory()
            obj_.build(child_)
            self.semData = obj_
            obj_.original_tagname_ = 'semData'
        elif nodeName_ == 'comData':
            obj_ = comData.factory()
            obj_.build(child_)
            self.comData = obj_
            obj_.original_tagname_ = 'comData'
        elif nodeName_ == 'noPeriodo':
            obj_ = noPeriodo.factory()
            obj_.build(child_)
            self.noPeriodo = obj_
            obj_.original_tagname_ = 'noPeriodo'
        elif nodeName_ == 'semHora':
            obj_ = semHora.factory()
            obj_.build(child_)
            self.semHora = obj_
            obj_.original_tagname_ = 'semHora'
        elif nodeName_ == 'comHora':
            obj_ = comHora.factory()
            obj_.build(child_)
            self.comHora = obj_
            obj_.original_tagname_ = 'comHora'
        elif nodeName_ == 'noInter':
            obj_ = noInter.factory()
            obj_.build(child_)
            self.noInter = obj_
            obj_.original_tagname_ = 'noInter'
# end class Entrega


class semData(GeneratedsSuper):
    """Entrega sem data definidaEsta opção é proibida para o modal aéreo."""
    subclass = None
    superclass = None
    def __init__(self, tpPer=None):
        self.original_tagname_ = None
        self.tpPer = tpPer
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, semData)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if semData.subclass:
            return semData.subclass(*args_, **kwargs_)
        else:
            return semData(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tpPer(self): return self.tpPer
    def set_tpPer(self, tpPer): self.tpPer = tpPer
    def hasContent_(self):
        if (
            self.tpPer is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='semData', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('semData')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='semData')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='semData', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='semData'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='semData', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpPer is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpPer>%s</%stpPer>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.tpPer), input_name='tpPer')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tpPer':
            tpPer_ = child_.text
            tpPer_ = self.gds_validate_string(tpPer_, node, 'tpPer')
            self.tpPer = tpPer_
# end class semData


class tpPer(GeneratedsSuper):
    """Tipo de data/período programado para entrega0- Sem data definida"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpPer)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpPer.subclass:
            return tpPer.subclass(*args_, **kwargs_)
        else:
            return tpPer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='tpPer', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpPer')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tpPer')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='tpPer', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='tpPer'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='tpPer', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class tpPer


class comData(GeneratedsSuper):
    """Entrega com data definida"""
    subclass = None
    superclass = None
    def __init__(self, tpPer=None, dProg=None):
        self.original_tagname_ = None
        self.tpPer = tpPer
        self.dProg = dProg
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, comData)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if comData.subclass:
            return comData.subclass(*args_, **kwargs_)
        else:
            return comData(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tpPer(self): return self.tpPer
    def set_tpPer(self, tpPer): self.tpPer = tpPer
    def get_dProg(self): return self.dProg
    def set_dProg(self, dProg): self.dProg = dProg
    def hasContent_(self):
        if (
            self.tpPer is not None or
            self.dProg is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='comData', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('comData')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='comData')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='comData', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='comData'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='comData', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpPer is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpPer>%s</%stpPer>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.tpPer), input_name='tpPer')), namespace_, eol_))
        if self.dProg is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdProg>%s</%sdProg>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.dProg), input_name='dProg')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tpPer':
            tpPer_ = child_.text
            tpPer_ = self.gds_validate_string(tpPer_, node, 'tpPer')
            self.tpPer = tpPer_
        elif nodeName_ == 'dProg':
            dProg_ = child_.text
            dProg_ = self.gds_validate_string(dProg_, node, 'dProg')
            self.dProg = dProg_
# end class comData


class noPeriodo(GeneratedsSuper):
    """Entrega no período definido"""
    subclass = None
    superclass = None
    def __init__(self, tpPer=None, dIni=None, dFim=None):
        self.original_tagname_ = None
        self.tpPer = tpPer
        self.dIni = dIni
        self.dFim = dFim
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, noPeriodo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if noPeriodo.subclass:
            return noPeriodo.subclass(*args_, **kwargs_)
        else:
            return noPeriodo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tpPer(self): return self.tpPer
    def set_tpPer(self, tpPer): self.tpPer = tpPer
    def get_dIni(self): return self.dIni
    def set_dIni(self, dIni): self.dIni = dIni
    def get_dFim(self): return self.dFim
    def set_dFim(self, dFim): self.dFim = dFim
    def hasContent_(self):
        if (
            self.tpPer is not None or
            self.dIni is not None or
            self.dFim is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='noPeriodo', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('noPeriodo')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='noPeriodo')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='noPeriodo', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='noPeriodo'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='noPeriodo', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpPer is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpPer>%s</%stpPer>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.tpPer), input_name='tpPer')), namespace_, eol_))
        if self.dIni is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdIni>%s</%sdIni>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.dIni), input_name='dIni')), namespace_, eol_))
        if self.dFim is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdFim>%s</%sdFim>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.dFim), input_name='dFim')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tpPer':
            tpPer_ = child_.text
            tpPer_ = self.gds_validate_string(tpPer_, node, 'tpPer')
            self.tpPer = tpPer_
        elif nodeName_ == 'dIni':
            dIni_ = child_.text
            dIni_ = self.gds_validate_string(dIni_, node, 'dIni')
            self.dIni = dIni_
        elif nodeName_ == 'dFim':
            dFim_ = child_.text
            dFim_ = self.gds_validate_string(dFim_, node, 'dFim')
            self.dFim = dFim_
# end class noPeriodo


class semHora(GeneratedsSuper):
    """Entrega sem hora definida"""
    subclass = None
    superclass = None
    def __init__(self, tpHor=None):
        self.original_tagname_ = None
        self.tpHor = tpHor
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, semHora)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if semHora.subclass:
            return semHora.subclass(*args_, **kwargs_)
        else:
            return semHora(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tpHor(self): return self.tpHor
    def set_tpHor(self, tpHor): self.tpHor = tpHor
    def hasContent_(self):
        if (
            self.tpHor is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='semHora', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('semHora')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='semHora')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='semHora', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='semHora'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='semHora', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpHor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpHor>%s</%stpHor>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.tpHor), input_name='tpHor')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tpHor':
            tpHor_ = child_.text
            tpHor_ = self.gds_validate_string(tpHor_, node, 'tpHor')
            self.tpHor = tpHor_
# end class semHora


class tpHor(GeneratedsSuper):
    """Tipo de hora0- Sem hora definida"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpHor)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpHor.subclass:
            return tpHor.subclass(*args_, **kwargs_)
        else:
            return tpHor(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='tpHor', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpHor')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tpHor')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='tpHor', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='tpHor'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='tpHor', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class tpHor


class comHora(GeneratedsSuper):
    """Entrega com hora definida"""
    subclass = None
    superclass = None
    def __init__(self, tpHor=None, hProg=None):
        self.original_tagname_ = None
        self.tpHor = tpHor
        self.hProg = hProg
        self.validate_TTime(self.hProg)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, comHora)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if comHora.subclass:
            return comHora.subclass(*args_, **kwargs_)
        else:
            return comHora(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tpHor(self): return self.tpHor
    def set_tpHor(self, tpHor): self.tpHor = tpHor
    def get_hProg(self): return self.hProg
    def set_hProg(self, hProg): self.hProg = hProg
    def validate_TTime(self, value):
        # Validate type TTime, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.tpHor is not None or
            self.hProg is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='comHora', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('comHora')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='comHora')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='comHora', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='comHora'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='comHora', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpHor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpHor>%s</%stpHor>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.tpHor), input_name='tpHor')), namespace_, eol_))
        if self.hProg is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shProg>%s</%shProg>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.hProg), input_name='hProg')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tpHor':
            tpHor_ = child_.text
            tpHor_ = self.gds_validate_string(tpHor_, node, 'tpHor')
            self.tpHor = tpHor_
        elif nodeName_ == 'hProg':
            hProg_ = child_.text
            hProg_ = self.gds_validate_string(hProg_, node, 'hProg')
            self.hProg = hProg_
            # validate type TTime
            self.validate_TTime(self.hProg)
# end class comHora


class noInter(GeneratedsSuper):
    """Entrega no intervalo de horário definido"""
    subclass = None
    superclass = None
    def __init__(self, tpHor=None, hIni=None, hFim=None):
        self.original_tagname_ = None
        self.tpHor = tpHor
        self.hIni = hIni
        self.validate_TTime(self.hIni)
        self.hFim = hFim
        self.validate_TTime(self.hFim)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, noInter)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if noInter.subclass:
            return noInter.subclass(*args_, **kwargs_)
        else:
            return noInter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tpHor(self): return self.tpHor
    def set_tpHor(self, tpHor): self.tpHor = tpHor
    def get_hIni(self): return self.hIni
    def set_hIni(self, hIni): self.hIni = hIni
    def get_hFim(self): return self.hFim
    def set_hFim(self, hFim): self.hFim = hFim
    def validate_TTime(self, value):
        # Validate type TTime, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.tpHor is not None or
            self.hIni is not None or
            self.hFim is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='noInter', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('noInter')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='noInter')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='noInter', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='noInter'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='noInter', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpHor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpHor>%s</%stpHor>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.tpHor), input_name='tpHor')), namespace_, eol_))
        if self.hIni is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shIni>%s</%shIni>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.hIni), input_name='hIni')), namespace_, eol_))
        if self.hFim is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shFim>%s</%shFim>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.hFim), input_name='hFim')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tpHor':
            tpHor_ = child_.text
            tpHor_ = self.gds_validate_string(tpHor_, node, 'tpHor')
            self.tpHor = tpHor_
        elif nodeName_ == 'hIni':
            hIni_ = child_.text
            hIni_ = self.gds_validate_string(hIni_, node, 'hIni')
            self.hIni = hIni_
            # validate type TTime
            self.validate_TTime(self.hIni)
        elif nodeName_ == 'hFim':
            hFim_ = child_.text
            hFim_ = self.gds_validate_string(hFim_, node, 'hFim')
            self.hFim = hFim_
            # validate type TTime
            self.validate_TTime(self.hFim)
# end class noInter


class origCalc(GeneratedsSuper):
    """Município de origem para efeito de cálculo do frete"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, origCalc)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if origCalc.subclass:
            return origCalc.subclass(*args_, **kwargs_)
        else:
            return origCalc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='origCalc', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('origCalc')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='origCalc')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='origCalc', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='origCalc'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='origCalc', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class origCalc


class destCalc(GeneratedsSuper):
    """Município de destino para efeito de cálculo do frete"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, destCalc)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if destCalc.subclass:
            return destCalc.subclass(*args_, **kwargs_)
        else:
            return destCalc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='destCalc', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('destCalc')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='destCalc')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='destCalc', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='destCalc'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='destCalc', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class destCalc


class xObs(GeneratedsSuper):
    """Observações Gerais"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, xObs)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if xObs.subclass:
            return xObs.subclass(*args_, **kwargs_)
        else:
            return xObs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='xObs', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('xObs')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='xObs')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='xObs', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='xObs'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='xObs', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class xObs


class ObsCont(GeneratedsSuper):
    """Campo de uso livre do contribuinteInformar o nome do campo no
    atributo xCampo e o conteúdo do campo no XTextoIdentificação do
    campo"""
    subclass = None
    superclass = None
    def __init__(self, xCampo=None, xTexto=None):
        self.original_tagname_ = None
        self.xCampo = _cast(None, xCampo)
        self.xTexto = xTexto
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ObsCont)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ObsCont.subclass:
            return ObsCont.subclass(*args_, **kwargs_)
        else:
            return ObsCont(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_xTexto(self): return self.xTexto
    def set_xTexto(self, xTexto): self.xTexto = xTexto
    def get_xCampo(self): return self.xCampo
    def set_xCampo(self, xCampo): self.xCampo = xCampo
    def hasContent_(self):
        if (
            self.xTexto is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ObsCont', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ObsCont')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ObsCont')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ObsCont', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ObsCont'):
        if self.xCampo is not None and 'xCampo' not in already_processed:
            already_processed.add('xCampo')
            outfile.write(' xCampo=%s' % (quote_attrib(self.xCampo), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ObsCont', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.xTexto is not None:
            self.xTexto.export(outfile, level, namespace_, name_='xTexto', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xCampo', node)
        if value is not None and 'xCampo' not in already_processed:
            already_processed.add('xCampo')
            self.xCampo = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'xTexto':
            obj_ = None
            self.xTexto = obj_
            obj_.original_tagname_ = 'xTexto'
# end class ObsCont


class xTexto(GeneratedsSuper):
    """Conteúdo do campo"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, xTexto)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if xTexto.subclass:
            return xTexto.subclass(*args_, **kwargs_)
        else:
            return xTexto(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='xTexto', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('xTexto')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='xTexto')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='xTexto', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='xTexto'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='xTexto', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class xTexto


class ObsFisco(GeneratedsSuper):
    """Campo de uso livre do contribuinteInformar o nome do campo no
    atributo xCampo e o conteúdo do campo no XTextoIdentificação do
    campo"""
    subclass = None
    superclass = None
    def __init__(self, xCampo=None, xTexto=None):
        self.original_tagname_ = None
        self.xCampo = _cast(None, xCampo)
        self.xTexto = xTexto
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ObsFisco)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ObsFisco.subclass:
            return ObsFisco.subclass(*args_, **kwargs_)
        else:
            return ObsFisco(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_xTexto(self): return self.xTexto
    def set_xTexto(self, xTexto): self.xTexto = xTexto
    def get_xCampo(self): return self.xCampo
    def set_xCampo(self, xCampo): self.xCampo = xCampo
    def hasContent_(self):
        if (
            self.xTexto is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ObsFisco', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ObsFisco')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ObsFisco')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ObsFisco', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ObsFisco'):
        if self.xCampo is not None and 'xCampo' not in already_processed:
            already_processed.add('xCampo')
            outfile.write(' xCampo=%s' % (quote_attrib(self.xCampo), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ObsFisco', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.xTexto is not None:
            self.xTexto.export(outfile, level, namespace_, name_='xTexto', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xCampo', node)
        if value is not None and 'xCampo' not in already_processed:
            already_processed.add('xCampo')
            self.xCampo = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'xTexto':
            obj_ = None
            self.xTexto = obj_
            obj_.original_tagname_ = 'xTexto'
# end class ObsFisco


class emit(GeneratedsSuper):
    """Identificação do Emitente do CT-e"""
    subclass = None
    superclass = None
    def __init__(self, CNPJ=None, IE=None, IEST=None, xNome=None, xFant=None, enderEmit=None):
        self.original_tagname_ = None
        self.CNPJ = CNPJ
        self.IE = IE
        self.IEST = IEST
        self.xNome = xNome
        self.xFant = xFant
        self.enderEmit = enderEmit
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, emit)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if emit.subclass:
            return emit.subclass(*args_, **kwargs_)
        else:
            return emit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CNPJ(self): return self.CNPJ
    def set_CNPJ(self, CNPJ): self.CNPJ = CNPJ
    def get_IE(self): return self.IE
    def set_IE(self, IE): self.IE = IE
    def get_IEST(self): return self.IEST
    def set_IEST(self, IEST): self.IEST = IEST
    def get_xNome(self): return self.xNome
    def set_xNome(self, xNome): self.xNome = xNome
    def get_xFant(self): return self.xFant
    def set_xFant(self, xFant): self.xFant = xFant
    def get_enderEmit(self): return self.enderEmit
    def set_enderEmit(self, enderEmit): self.enderEmit = enderEmit
    def hasContent_(self):
        if (
            self.CNPJ is not None or
            self.IE is not None or
            self.IEST is not None or
            self.xNome is not None or
            self.xFant is not None or
            self.enderEmit is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='emit', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('emit')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='emit')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='emit', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='emit'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='emit', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CNPJ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCNPJ>%s</%sCNPJ>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CNPJ), input_name='CNPJ')), namespace_, eol_))
        if self.IE is not None:
            self.IE.export(outfile, level, namespace_, name_='IE', pretty_print=pretty_print)
        if self.IEST is not None:
            self.IEST.export(outfile, level, namespace_, name_='IEST', pretty_print=pretty_print)
        if self.xNome is not None:
            self.xNome.export(outfile, level, namespace_, name_='xNome', pretty_print=pretty_print)
        if self.xFant is not None:
            self.xFant.export(outfile, level, namespace_, name_='xFant', pretty_print=pretty_print)
        if self.enderEmit is not None:
            self.enderEmit.export(outfile, level, namespace_, name_='enderEmit', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CNPJ':
            CNPJ_ = child_.text
            CNPJ_ = self.gds_validate_string(CNPJ_, node, 'CNPJ')
            self.CNPJ = CNPJ_
        elif nodeName_ == 'IE':
            obj_ = None
            self.IE = obj_
            obj_.original_tagname_ = 'IE'
        elif nodeName_ == 'IEST':
            obj_ = None
            self.IEST = obj_
            obj_.original_tagname_ = 'IEST'
        elif nodeName_ == 'xNome':
            obj_ = None
            self.xNome = obj_
            obj_.original_tagname_ = 'xNome'
        elif nodeName_ == 'xFant':
            obj_ = None
            self.xFant = obj_
            obj_.original_tagname_ = 'xFant'
        elif nodeName_ == 'enderEmit':
            obj_ = TEndeEmi.factory()
            obj_.build(child_)
            self.enderEmit = obj_
            obj_.original_tagname_ = 'enderEmit'
# end class emit


class IEST(GeneratedsSuper):
    """Inscrição Estadual do Substituto Tributário"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IEST)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IEST.subclass:
            return IEST.subclass(*args_, **kwargs_)
        else:
            return IEST(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IEST', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IEST')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IEST')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IEST', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IEST'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='IEST', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class IEST


class rem(GeneratedsSuper):
    """Informações do Remetente das mercadorias transportadas pelo CT-
    ePoderá não ser informado para os CT-e de redespacho
    intermediário e serviço vinculado a multimodal. Nos demais casos
    deverá sempre ser informado."""
    subclass = None
    superclass = None
    def __init__(self, CNPJ=None, CPF=None, IE=None, xNome=None, xFant=None, fone=None, enderReme=None, email=None):
        self.original_tagname_ = None
        self.CNPJ = CNPJ
        self.CPF = CPF
        self.IE = IE
        self.xNome = xNome
        self.xFant = xFant
        self.fone = fone
        self.enderReme = enderReme
        self.email = email
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, rem)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if rem.subclass:
            return rem.subclass(*args_, **kwargs_)
        else:
            return rem(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CNPJ(self): return self.CNPJ
    def set_CNPJ(self, CNPJ): self.CNPJ = CNPJ
    def get_CPF(self): return self.CPF
    def set_CPF(self, CPF): self.CPF = CPF
    def get_IE(self): return self.IE
    def set_IE(self, IE): self.IE = IE
    def get_xNome(self): return self.xNome
    def set_xNome(self, xNome): self.xNome = xNome
    def get_xFant(self): return self.xFant
    def set_xFant(self, xFant): self.xFant = xFant
    def get_fone(self): return self.fone
    def set_fone(self, fone): self.fone = fone
    def get_enderReme(self): return self.enderReme
    def set_enderReme(self, enderReme): self.enderReme = enderReme
    def get_email(self): return self.email
    def set_email(self, email): self.email = email
    def hasContent_(self):
        if (
            self.CNPJ is not None or
            self.CPF is not None or
            self.IE is not None or
            self.xNome is not None or
            self.xFant is not None or
            self.fone is not None or
            self.enderReme is not None or
            self.email is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='rem', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('rem')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='rem')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='rem', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='rem'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='rem', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CNPJ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCNPJ>%s</%sCNPJ>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CNPJ), input_name='CNPJ')), namespace_, eol_))
        if self.CPF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCPF>%s</%sCPF>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CPF), input_name='CPF')), namespace_, eol_))
        if self.IE is not None:
            self.IE.export(outfile, level, namespace_, name_='IE', pretty_print=pretty_print)
        if self.xNome is not None:
            self.xNome.export(outfile, level, namespace_, name_='xNome', pretty_print=pretty_print)
        if self.xFant is not None:
            self.xFant.export(outfile, level, namespace_, name_='xFant', pretty_print=pretty_print)
        if self.fone is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfone>%s</%sfone>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.fone), input_name='fone')), namespace_, eol_))
        if self.enderReme is not None:
            self.enderReme.export(outfile, level, namespace_, name_='enderReme', pretty_print=pretty_print)
        if self.email is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%semail>%s</%semail>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.email), input_name='email')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CNPJ':
            CNPJ_ = child_.text
            CNPJ_ = self.gds_validate_string(CNPJ_, node, 'CNPJ')
            self.CNPJ = CNPJ_
        elif nodeName_ == 'CPF':
            CPF_ = child_.text
            CPF_ = self.gds_validate_string(CPF_, node, 'CPF')
            self.CPF = CPF_
        elif nodeName_ == 'IE':
            obj_ = None
            self.IE = obj_
            obj_.original_tagname_ = 'IE'
        elif nodeName_ == 'xNome':
            obj_ = None
            self.xNome = obj_
            obj_.original_tagname_ = 'xNome'
        elif nodeName_ == 'xFant':
            obj_ = None
            self.xFant = obj_
            obj_.original_tagname_ = 'xFant'
        elif nodeName_ == 'fone':
            fone_ = child_.text
            fone_ = self.gds_validate_string(fone_, node, 'fone')
            self.fone = fone_
        elif nodeName_ == 'enderReme':
            obj_ = TEndereco.factory()
            obj_.build(child_)
            self.enderReme = obj_
            obj_.original_tagname_ = 'enderReme'
        elif nodeName_ == 'email':
            email_ = child_.text
            email_ = self.gds_validate_string(email_, node, 'email')
            self.email = email_
# end class rem


class email(GeneratedsSuper):
    """Endereço de email"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, email)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if email.subclass:
            return email.subclass(*args_, **kwargs_)
        else:
            return email(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='email', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('email')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='email')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='email', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='email'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='email', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class email


class exped(GeneratedsSuper):
    """Informações do Expedidor da Carga"""
    subclass = None
    superclass = None
    def __init__(self, CNPJ=None, CPF=None, IE=None, xNome=None, fone=None, enderExped=None, email=None):
        self.original_tagname_ = None
        self.CNPJ = CNPJ
        self.CPF = CPF
        self.IE = IE
        self.xNome = xNome
        self.fone = fone
        self.enderExped = enderExped
        self.email = email
        self.validate_TEmail(self.email)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, exped)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if exped.subclass:
            return exped.subclass(*args_, **kwargs_)
        else:
            return exped(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CNPJ(self): return self.CNPJ
    def set_CNPJ(self, CNPJ): self.CNPJ = CNPJ
    def get_CPF(self): return self.CPF
    def set_CPF(self, CPF): self.CPF = CPF
    def get_IE(self): return self.IE
    def set_IE(self, IE): self.IE = IE
    def get_xNome(self): return self.xNome
    def set_xNome(self, xNome): self.xNome = xNome
    def get_fone(self): return self.fone
    def set_fone(self, fone): self.fone = fone
    def get_enderExped(self): return self.enderExped
    def set_enderExped(self, enderExped): self.enderExped = enderExped
    def get_email(self): return self.email
    def set_email(self, email): self.email = email
    def validate_TEmail(self, value):
        # Validate type TEmail, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.CNPJ is not None or
            self.CPF is not None or
            self.IE is not None or
            self.xNome is not None or
            self.fone is not None or
            self.enderExped is not None or
            self.email is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='exped', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('exped')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='exped')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='exped', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='exped'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='exped', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CNPJ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCNPJ>%s</%sCNPJ>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CNPJ), input_name='CNPJ')), namespace_, eol_))
        if self.CPF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCPF>%s</%sCPF>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CPF), input_name='CPF')), namespace_, eol_))
        if self.IE is not None:
            self.IE.export(outfile, level, namespace_, name_='IE', pretty_print=pretty_print)
        if self.xNome is not None:
            self.xNome.export(outfile, level, namespace_, name_='xNome', pretty_print=pretty_print)
        if self.fone is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfone>%s</%sfone>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.fone), input_name='fone')), namespace_, eol_))
        if self.enderExped is not None:
            self.enderExped.export(outfile, level, namespace_, name_='enderExped', pretty_print=pretty_print)
        if self.email is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%semail>%s</%semail>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.email), input_name='email')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CNPJ':
            CNPJ_ = child_.text
            CNPJ_ = self.gds_validate_string(CNPJ_, node, 'CNPJ')
            self.CNPJ = CNPJ_
        elif nodeName_ == 'CPF':
            CPF_ = child_.text
            CPF_ = self.gds_validate_string(CPF_, node, 'CPF')
            self.CPF = CPF_
        elif nodeName_ == 'IE':
            obj_ = None
            self.IE = obj_
            obj_.original_tagname_ = 'IE'
        elif nodeName_ == 'xNome':
            obj_ = None
            self.xNome = obj_
            obj_.original_tagname_ = 'xNome'
        elif nodeName_ == 'fone':
            fone_ = child_.text
            fone_ = self.gds_validate_string(fone_, node, 'fone')
            self.fone = fone_
        elif nodeName_ == 'enderExped':
            obj_ = TEndereco.factory()
            obj_.build(child_)
            self.enderExped = obj_
            obj_.original_tagname_ = 'enderExped'
        elif nodeName_ == 'email':
            email_ = child_.text
            email_ = self.gds_validate_string(email_, node, 'email')
            self.email = email_
            # validate type TEmail
            self.validate_TEmail(self.email)
# end class exped


class receb(GeneratedsSuper):
    """Informações do Recebedor da Carga"""
    subclass = None
    superclass = None
    def __init__(self, CNPJ=None, CPF=None, IE=None, xNome=None, fone=None, enderReceb=None, email=None):
        self.original_tagname_ = None
        self.CNPJ = CNPJ
        self.CPF = CPF
        self.IE = IE
        self.xNome = xNome
        self.fone = fone
        self.enderReceb = enderReceb
        self.email = email
        self.validate_TEmail(self.email)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, receb)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if receb.subclass:
            return receb.subclass(*args_, **kwargs_)
        else:
            return receb(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CNPJ(self): return self.CNPJ
    def set_CNPJ(self, CNPJ): self.CNPJ = CNPJ
    def get_CPF(self): return self.CPF
    def set_CPF(self, CPF): self.CPF = CPF
    def get_IE(self): return self.IE
    def set_IE(self, IE): self.IE = IE
    def get_xNome(self): return self.xNome
    def set_xNome(self, xNome): self.xNome = xNome
    def get_fone(self): return self.fone
    def set_fone(self, fone): self.fone = fone
    def get_enderReceb(self): return self.enderReceb
    def set_enderReceb(self, enderReceb): self.enderReceb = enderReceb
    def get_email(self): return self.email
    def set_email(self, email): self.email = email
    def validate_TEmail(self, value):
        # Validate type TEmail, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.CNPJ is not None or
            self.CPF is not None or
            self.IE is not None or
            self.xNome is not None or
            self.fone is not None or
            self.enderReceb is not None or
            self.email is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='receb', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('receb')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='receb')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='receb', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='receb'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='receb', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CNPJ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCNPJ>%s</%sCNPJ>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CNPJ), input_name='CNPJ')), namespace_, eol_))
        if self.CPF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCPF>%s</%sCPF>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CPF), input_name='CPF')), namespace_, eol_))
        if self.IE is not None:
            self.IE.export(outfile, level, namespace_, name_='IE', pretty_print=pretty_print)
        if self.xNome is not None:
            self.xNome.export(outfile, level, namespace_, name_='xNome', pretty_print=pretty_print)
        if self.fone is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfone>%s</%sfone>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.fone), input_name='fone')), namespace_, eol_))
        if self.enderReceb is not None:
            self.enderReceb.export(outfile, level, namespace_, name_='enderReceb', pretty_print=pretty_print)
        if self.email is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%semail>%s</%semail>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.email), input_name='email')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CNPJ':
            CNPJ_ = child_.text
            CNPJ_ = self.gds_validate_string(CNPJ_, node, 'CNPJ')
            self.CNPJ = CNPJ_
        elif nodeName_ == 'CPF':
            CPF_ = child_.text
            CPF_ = self.gds_validate_string(CPF_, node, 'CPF')
            self.CPF = CPF_
        elif nodeName_ == 'IE':
            obj_ = None
            self.IE = obj_
            obj_.original_tagname_ = 'IE'
        elif nodeName_ == 'xNome':
            obj_ = None
            self.xNome = obj_
            obj_.original_tagname_ = 'xNome'
        elif nodeName_ == 'fone':
            fone_ = child_.text
            fone_ = self.gds_validate_string(fone_, node, 'fone')
            self.fone = fone_
        elif nodeName_ == 'enderReceb':
            obj_ = TEndereco.factory()
            obj_.build(child_)
            self.enderReceb = obj_
            obj_.original_tagname_ = 'enderReceb'
        elif nodeName_ == 'email':
            email_ = child_.text
            email_ = self.gds_validate_string(email_, node, 'email')
            self.email = email_
            # validate type TEmail
            self.validate_TEmail(self.email)
# end class receb


class dest(GeneratedsSuper):
    """Informações do Destinatário do CT-eSó pode ser omitido em caso de
    redespacho intermediário"""
    subclass = None
    superclass = None
    def __init__(self, CNPJ=None, CPF=None, IE=None, xNome=None, fone=None, ISUF=None, enderDest=None, email=None):
        self.original_tagname_ = None
        self.CNPJ = CNPJ
        self.CPF = CPF
        self.IE = IE
        self.xNome = xNome
        self.fone = fone
        self.ISUF = ISUF
        self.enderDest = enderDest
        self.email = email
        self.validate_TEmail(self.email)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, dest)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if dest.subclass:
            return dest.subclass(*args_, **kwargs_)
        else:
            return dest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CNPJ(self): return self.CNPJ
    def set_CNPJ(self, CNPJ): self.CNPJ = CNPJ
    def get_CPF(self): return self.CPF
    def set_CPF(self, CPF): self.CPF = CPF
    def get_IE(self): return self.IE
    def set_IE(self, IE): self.IE = IE
    def get_xNome(self): return self.xNome
    def set_xNome(self, xNome): self.xNome = xNome
    def get_fone(self): return self.fone
    def set_fone(self, fone): self.fone = fone
    def get_ISUF(self): return self.ISUF
    def set_ISUF(self, ISUF): self.ISUF = ISUF
    def get_enderDest(self): return self.enderDest
    def set_enderDest(self, enderDest): self.enderDest = enderDest
    def get_email(self): return self.email
    def set_email(self, email): self.email = email
    def validate_TEmail(self, value):
        # Validate type TEmail, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.CNPJ is not None or
            self.CPF is not None or
            self.IE is not None or
            self.xNome is not None or
            self.fone is not None or
            self.ISUF is not None or
            self.enderDest is not None or
            self.email is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='dest', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('dest')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='dest')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='dest', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='dest'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='dest', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CNPJ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCNPJ>%s</%sCNPJ>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CNPJ), input_name='CNPJ')), namespace_, eol_))
        if self.CPF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCPF>%s</%sCPF>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CPF), input_name='CPF')), namespace_, eol_))
        if self.IE is not None:
            self.IE.export(outfile, level, namespace_, name_='IE', pretty_print=pretty_print)
        if self.xNome is not None:
            self.xNome.export(outfile, level, namespace_, name_='xNome', pretty_print=pretty_print)
        if self.fone is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfone>%s</%sfone>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.fone), input_name='fone')), namespace_, eol_))
        if self.ISUF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sISUF>%s</%sISUF>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ISUF), input_name='ISUF')), namespace_, eol_))
        if self.enderDest is not None:
            self.enderDest.export(outfile, level, namespace_, name_='enderDest', pretty_print=pretty_print)
        if self.email is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%semail>%s</%semail>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.email), input_name='email')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CNPJ':
            CNPJ_ = child_.text
            CNPJ_ = self.gds_validate_string(CNPJ_, node, 'CNPJ')
            self.CNPJ = CNPJ_
        elif nodeName_ == 'CPF':
            CPF_ = child_.text
            CPF_ = self.gds_validate_string(CPF_, node, 'CPF')
            self.CPF = CPF_
        elif nodeName_ == 'IE':
            obj_ = None
            self.IE = obj_
            obj_.original_tagname_ = 'IE'
        elif nodeName_ == 'xNome':
            obj_ = None
            self.xNome = obj_
            obj_.original_tagname_ = 'xNome'
        elif nodeName_ == 'fone':
            fone_ = child_.text
            fone_ = self.gds_validate_string(fone_, node, 'fone')
            self.fone = fone_
        elif nodeName_ == 'ISUF':
            ISUF_ = child_.text
            ISUF_ = self.gds_validate_string(ISUF_, node, 'ISUF')
            self.ISUF = ISUF_
        elif nodeName_ == 'enderDest':
            obj_ = TEndereco.factory()
            obj_.build(child_)
            self.enderDest = obj_
            obj_.original_tagname_ = 'enderDest'
        elif nodeName_ == 'email':
            email_ = child_.text
            email_ = self.gds_validate_string(email_, node, 'email')
            self.email = email_
            # validate type TEmail
            self.validate_TEmail(self.email)
# end class dest


class ISUF(GeneratedsSuper):
    """Inscrição na SUFRAMA(Obrigatório nas operações com as áreas com
    benefícios de incentivos fiscais sob controle da SUFRAMA)"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ISUF)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ISUF.subclass:
            return ISUF.subclass(*args_, **kwargs_)
        else:
            return ISUF(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ISUF', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ISUF')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ISUF')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ISUF', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ISUF'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ISUF', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ISUF


class vPrest(GeneratedsSuper):
    """Valores da Prestação de Serviço"""
    subclass = None
    superclass = None
    def __init__(self, vTPrest=None, vRec=None, Comp=None):
        self.original_tagname_ = None
        self.vTPrest = vTPrest
        self.vRec = vRec
        if Comp is None:
            self.Comp = []
        else:
            self.Comp = Comp
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, vPrest)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if vPrest.subclass:
            return vPrest.subclass(*args_, **kwargs_)
        else:
            return vPrest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vTPrest(self): return self.vTPrest
    def set_vTPrest(self, vTPrest): self.vTPrest = vTPrest
    def get_vRec(self): return self.vRec
    def set_vRec(self, vRec): self.vRec = vRec
    def get_Comp(self): return self.Comp
    def set_Comp(self, Comp): self.Comp = Comp
    def add_Comp(self, value): self.Comp.append(value)
    def insert_Comp_at(self, index, value): self.Comp.insert(index, value)
    def replace_Comp_at(self, index, value): self.Comp[index] = value
    def hasContent_(self):
        if (
            self.vTPrest is not None or
            self.vRec is not None or
            self.Comp
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='vPrest', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vPrest')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='vPrest')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='vPrest', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='vPrest'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='vPrest', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vTPrest is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svTPrest>%s</%svTPrest>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.vTPrest), input_name='vTPrest')), namespace_, eol_))
        if self.vRec is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svRec>%s</%svRec>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.vRec), input_name='vRec')), namespace_, eol_))
        for Comp_ in self.Comp:
            Comp_.export(outfile, level, namespace_, name_='Comp', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vTPrest':
            vTPrest_ = child_.text
            vTPrest_ = self.gds_validate_string(vTPrest_, node, 'vTPrest')
            self.vTPrest = vTPrest_
        elif nodeName_ == 'vRec':
            vRec_ = child_.text
            vRec_ = self.gds_validate_string(vRec_, node, 'vRec')
            self.vRec = vRec_
        elif nodeName_ == 'Comp':
            obj_ = Comp.factory()
            obj_.build(child_)
            self.Comp.append(obj_)
            obj_.original_tagname_ = 'Comp'
# end class vPrest


class Comp(GeneratedsSuper):
    """Componentes do Valor da Prestação"""
    subclass = None
    superclass = None
    def __init__(self, xNome=None, vComp=None):
        self.original_tagname_ = None
        self.xNome = xNome
        self.vComp = vComp
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Comp)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Comp.subclass:
            return Comp.subclass(*args_, **kwargs_)
        else:
            return Comp(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_xNome(self): return self.xNome
    def set_xNome(self, xNome): self.xNome = xNome
    def get_vComp(self): return self.vComp
    def set_vComp(self, vComp): self.vComp = vComp
    def hasContent_(self):
        if (
            self.xNome is not None or
            self.vComp is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Comp', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Comp')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Comp')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Comp', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Comp'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Comp', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.xNome is not None:
            self.xNome.export(outfile, level, namespace_, name_='xNome', pretty_print=pretty_print)
        if self.vComp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svComp>%s</%svComp>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.vComp), input_name='vComp')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'xNome':
            obj_ = None
            self.xNome = obj_
            obj_.original_tagname_ = 'xNome'
        elif nodeName_ == 'vComp':
            vComp_ = child_.text
            vComp_ = self.gds_validate_string(vComp_, node, 'vComp')
            self.vComp = vComp_
# end class Comp


class imp(GeneratedsSuper):
    """Informações relativas aos Impostos"""
    subclass = None
    superclass = None
    def __init__(self, ICMS=None, vTotTrib=None, infAdFisco=None, ICMSUFFim=None):
        self.original_tagname_ = None
        self.ICMS = ICMS
        self.vTotTrib = vTotTrib
        self.infAdFisco = infAdFisco
        self.ICMSUFFim = ICMSUFFim
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, imp)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if imp.subclass:
            return imp.subclass(*args_, **kwargs_)
        else:
            return imp(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ICMS(self): return self.ICMS
    def set_ICMS(self, ICMS): self.ICMS = ICMS
    def get_vTotTrib(self): return self.vTotTrib
    def set_vTotTrib(self, vTotTrib): self.vTotTrib = vTotTrib
    def get_infAdFisco(self): return self.infAdFisco
    def set_infAdFisco(self, infAdFisco): self.infAdFisco = infAdFisco
    def get_ICMSUFFim(self): return self.ICMSUFFim
    def set_ICMSUFFim(self, ICMSUFFim): self.ICMSUFFim = ICMSUFFim
    def hasContent_(self):
        if (
            self.ICMS is not None or
            self.vTotTrib is not None or
            self.infAdFisco is not None or
            self.ICMSUFFim is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='imp', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('imp')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='imp')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='imp', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='imp'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='imp', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ICMS is not None:
            self.ICMS.export(outfile, level, namespace_, name_='ICMS', pretty_print=pretty_print)
        if self.vTotTrib is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svTotTrib>%s</%svTotTrib>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.vTotTrib), input_name='vTotTrib')), namespace_, eol_))
        if self.infAdFisco is not None:
            self.infAdFisco.export(outfile, level, namespace_, name_='infAdFisco', pretty_print=pretty_print)
        if self.ICMSUFFim is not None:
            self.ICMSUFFim.export(outfile, level, namespace_, name_='ICMSUFFim', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ICMS':
            obj_ = TImp.factory()
            obj_.build(child_)
            self.ICMS = obj_
            obj_.original_tagname_ = 'ICMS'
        elif nodeName_ == 'vTotTrib':
            vTotTrib_ = child_.text
            vTotTrib_ = self.gds_validate_string(vTotTrib_, node, 'vTotTrib')
            self.vTotTrib = vTotTrib_
        elif nodeName_ == 'infAdFisco':
            obj_ = None
            self.infAdFisco = obj_
            obj_.original_tagname_ = 'infAdFisco'
        elif nodeName_ == 'ICMSUFFim':
            obj_ = ICMSUFFim.factory()
            obj_.build(child_)
            self.ICMSUFFim = obj_
            obj_.original_tagname_ = 'ICMSUFFim'
# end class imp


class infAdFisco(GeneratedsSuper):
    """Informações adicionais de interesse do FiscoNorma referenciada,
    informações complementares, etc"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infAdFisco)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infAdFisco.subclass:
            return infAdFisco.subclass(*args_, **kwargs_)
        else:
            return infAdFisco(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infAdFisco', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infAdFisco')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infAdFisco')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infAdFisco', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infAdFisco'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infAdFisco', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class infAdFisco


class ICMSUFFim(GeneratedsSuper):
    """Informações do ICMS de partilha com a UF de término do serviço de
    transporte na operação interestadualGrupo a ser informado nas
    prestações interestaduais para consumidor final, não
    contribuinte do ICMS"""
    subclass = None
    superclass = None
    def __init__(self, vBCUFFim=None, pFCPUFFim=None, pICMSUFFim=None, pICMSInter=None, pICMSInterPart=None, vFCPUFFim=None, vICMSUFFim=None, vICMSUFIni=None):
        self.original_tagname_ = None
        self.vBCUFFim = vBCUFFim
        self.pFCPUFFim = pFCPUFFim
        self.pICMSUFFim = pICMSUFFim
        self.pICMSInter = pICMSInter
        self.pICMSInterPart = pICMSInterPart
        self.vFCPUFFim = vFCPUFFim
        self.vICMSUFFim = vICMSUFFim
        self.vICMSUFIni = vICMSUFIni
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMSUFFim)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMSUFFim.subclass:
            return ICMSUFFim.subclass(*args_, **kwargs_)
        else:
            return ICMSUFFim(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vBCUFFim(self): return self.vBCUFFim
    def set_vBCUFFim(self, vBCUFFim): self.vBCUFFim = vBCUFFim
    def get_pFCPUFFim(self): return self.pFCPUFFim
    def set_pFCPUFFim(self, pFCPUFFim): self.pFCPUFFim = pFCPUFFim
    def get_pICMSUFFim(self): return self.pICMSUFFim
    def set_pICMSUFFim(self, pICMSUFFim): self.pICMSUFFim = pICMSUFFim
    def get_pICMSInter(self): return self.pICMSInter
    def set_pICMSInter(self, pICMSInter): self.pICMSInter = pICMSInter
    def get_pICMSInterPart(self): return self.pICMSInterPart
    def set_pICMSInterPart(self, pICMSInterPart): self.pICMSInterPart = pICMSInterPart
    def get_vFCPUFFim(self): return self.vFCPUFFim
    def set_vFCPUFFim(self, vFCPUFFim): self.vFCPUFFim = vFCPUFFim
    def get_vICMSUFFim(self): return self.vICMSUFFim
    def set_vICMSUFFim(self, vICMSUFFim): self.vICMSUFFim = vICMSUFFim
    def get_vICMSUFIni(self): return self.vICMSUFIni
    def set_vICMSUFIni(self, vICMSUFIni): self.vICMSUFIni = vICMSUFIni
    def hasContent_(self):
        if (
            self.vBCUFFim is not None or
            self.pFCPUFFim is not None or
            self.pICMSUFFim is not None or
            self.pICMSInter is not None or
            self.pICMSInterPart is not None or
            self.vFCPUFFim is not None or
            self.vICMSUFFim is not None or
            self.vICMSUFIni is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ICMSUFFim', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMSUFFim')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ICMSUFFim')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ICMSUFFim', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ICMSUFFim'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ICMSUFFim', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vBCUFFim is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBCUFFim>%s</%svBCUFFim>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.vBCUFFim), input_name='vBCUFFim')), namespace_, eol_))
        if self.pFCPUFFim is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spFCPUFFim>%s</%spFCPUFFim>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.pFCPUFFim), input_name='pFCPUFFim')), namespace_, eol_))
        if self.pICMSUFFim is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spICMSUFFim>%s</%spICMSUFFim>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.pICMSUFFim), input_name='pICMSUFFim')), namespace_, eol_))
        if self.pICMSInter is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spICMSInter>%s</%spICMSInter>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.pICMSInter), input_name='pICMSInter')), namespace_, eol_))
        if self.pICMSInterPart is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spICMSInterPart>%s</%spICMSInterPart>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.pICMSInterPart), input_name='pICMSInterPart')), namespace_, eol_))
        if self.vFCPUFFim is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svFCPUFFim>%s</%svFCPUFFim>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.vFCPUFFim), input_name='vFCPUFFim')), namespace_, eol_))
        if self.vICMSUFFim is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svICMSUFFim>%s</%svICMSUFFim>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.vICMSUFFim), input_name='vICMSUFFim')), namespace_, eol_))
        if self.vICMSUFIni is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svICMSUFIni>%s</%svICMSUFIni>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.vICMSUFIni), input_name='vICMSUFIni')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vBCUFFim':
            vBCUFFim_ = child_.text
            vBCUFFim_ = self.gds_validate_string(vBCUFFim_, node, 'vBCUFFim')
            self.vBCUFFim = vBCUFFim_
        elif nodeName_ == 'pFCPUFFim':
            pFCPUFFim_ = child_.text
            pFCPUFFim_ = self.gds_validate_string(pFCPUFFim_, node, 'pFCPUFFim')
            self.pFCPUFFim = pFCPUFFim_
        elif nodeName_ == 'pICMSUFFim':
            pICMSUFFim_ = child_.text
            pICMSUFFim_ = self.gds_validate_string(pICMSUFFim_, node, 'pICMSUFFim')
            self.pICMSUFFim = pICMSUFFim_
        elif nodeName_ == 'pICMSInter':
            pICMSInter_ = child_.text
            pICMSInter_ = self.gds_validate_string(pICMSInter_, node, 'pICMSInter')
            self.pICMSInter = pICMSInter_
        elif nodeName_ == 'pICMSInterPart':
            pICMSInterPart_ = child_.text
            pICMSInterPart_ = self.gds_validate_string(pICMSInterPart_, node, 'pICMSInterPart')
            self.pICMSInterPart = pICMSInterPart_
        elif nodeName_ == 'vFCPUFFim':
            vFCPUFFim_ = child_.text
            vFCPUFFim_ = self.gds_validate_string(vFCPUFFim_, node, 'vFCPUFFim')
            self.vFCPUFFim = vFCPUFFim_
        elif nodeName_ == 'vICMSUFFim':
            vICMSUFFim_ = child_.text
            vICMSUFFim_ = self.gds_validate_string(vICMSUFFim_, node, 'vICMSUFFim')
            self.vICMSUFFim = vICMSUFFim_
        elif nodeName_ == 'vICMSUFIni':
            vICMSUFIni_ = child_.text
            vICMSUFIni_ = self.gds_validate_string(vICMSUFIni_, node, 'vICMSUFIni')
            self.vICMSUFIni = vICMSUFIni_
# end class ICMSUFFim


class infCTeNorm(GeneratedsSuper):
    """Grupo de informações do CT-e Normal e Substituto"""
    subclass = None
    superclass = None
    def __init__(self, infCarga=None, infDoc=None, docAnt=None, infModal=None, veicNovos=None, cobr=None, infCteSub=None, infGlobalizado=None, infServVinc=None):
        self.original_tagname_ = None
        self.infCarga = infCarga
        self.infDoc = infDoc
        self.docAnt = docAnt
        self.infModal = infModal
        if veicNovos is None:
            self.veicNovos = []
        else:
            self.veicNovos = veicNovos
        self.cobr = cobr
        self.infCteSub = infCteSub
        self.infGlobalizado = infGlobalizado
        self.infServVinc = infServVinc
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infCTeNorm)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infCTeNorm.subclass:
            return infCTeNorm.subclass(*args_, **kwargs_)
        else:
            return infCTeNorm(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_infCarga(self): return self.infCarga
    def set_infCarga(self, infCarga): self.infCarga = infCarga
    def get_infDoc(self): return self.infDoc
    def set_infDoc(self, infDoc): self.infDoc = infDoc
    def get_docAnt(self): return self.docAnt
    def set_docAnt(self, docAnt): self.docAnt = docAnt
    def get_infModal(self): return self.infModal
    def set_infModal(self, infModal): self.infModal = infModal
    def get_veicNovos(self): return self.veicNovos
    def set_veicNovos(self, veicNovos): self.veicNovos = veicNovos
    def add_veicNovos(self, value): self.veicNovos.append(value)
    def insert_veicNovos_at(self, index, value): self.veicNovos.insert(index, value)
    def replace_veicNovos_at(self, index, value): self.veicNovos[index] = value
    def get_cobr(self): return self.cobr
    def set_cobr(self, cobr): self.cobr = cobr
    def get_infCteSub(self): return self.infCteSub
    def set_infCteSub(self, infCteSub): self.infCteSub = infCteSub
    def get_infGlobalizado(self): return self.infGlobalizado
    def set_infGlobalizado(self, infGlobalizado): self.infGlobalizado = infGlobalizado
    def get_infServVinc(self): return self.infServVinc
    def set_infServVinc(self, infServVinc): self.infServVinc = infServVinc
    def hasContent_(self):
        if (
            self.infCarga is not None or
            self.infDoc is not None or
            self.docAnt is not None or
            self.infModal is not None or
            self.veicNovos or
            self.cobr is not None or
            self.infCteSub is not None or
            self.infGlobalizado is not None or
            self.infServVinc is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infCTeNorm', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infCTeNorm')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infCTeNorm')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infCTeNorm', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infCTeNorm'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infCTeNorm', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.infCarga is not None:
            self.infCarga.export(outfile, level, namespace_, name_='infCarga', pretty_print=pretty_print)
        if self.infDoc is not None:
            self.infDoc.export(outfile, level, namespace_, name_='infDoc', pretty_print=pretty_print)
        if self.docAnt is not None:
            self.docAnt.export(outfile, level, namespace_, name_='docAnt', pretty_print=pretty_print)
        if self.infModal is not None:
            self.infModal.export(outfile, level, namespace_, name_='infModal', pretty_print=pretty_print)
        for veicNovos_ in self.veicNovos:
            veicNovos_.export(outfile, level, namespace_, name_='veicNovos', pretty_print=pretty_print)
        if self.cobr is not None:
            self.cobr.export(outfile, level, namespace_, name_='cobr', pretty_print=pretty_print)
        if self.infCteSub is not None:
            self.infCteSub.export(outfile, level, namespace_, name_='infCteSub', pretty_print=pretty_print)
        if self.infGlobalizado is not None:
            self.infGlobalizado.export(outfile, level, namespace_, name_='infGlobalizado', pretty_print=pretty_print)
        if self.infServVinc is not None:
            self.infServVinc.export(outfile, level, namespace_, name_='infServVinc', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'infCarga':
            obj_ = infCarga.factory()
            obj_.build(child_)
            self.infCarga = obj_
            obj_.original_tagname_ = 'infCarga'
        elif nodeName_ == 'infDoc':
            obj_ = infDoc.factory()
            obj_.build(child_)
            self.infDoc = obj_
            obj_.original_tagname_ = 'infDoc'
        elif nodeName_ == 'docAnt':
            obj_ = docAnt.factory()
            obj_.build(child_)
            self.docAnt = obj_
            obj_.original_tagname_ = 'docAnt'
        elif nodeName_ == 'infModal':
            obj_ = infModal.factory()
            obj_.build(child_)
            self.infModal = obj_
            obj_.original_tagname_ = 'infModal'
        elif nodeName_ == 'veicNovos':
            obj_ = veicNovos.factory()
            obj_.build(child_)
            self.veicNovos.append(obj_)
            obj_.original_tagname_ = 'veicNovos'
        elif nodeName_ == 'cobr':
            obj_ = cobr.factory()
            obj_.build(child_)
            self.cobr = obj_
            obj_.original_tagname_ = 'cobr'
        elif nodeName_ == 'infCteSub':
            obj_ = infCteSub.factory()
            obj_.build(child_)
            self.infCteSub = obj_
            obj_.original_tagname_ = 'infCteSub'
        elif nodeName_ == 'infGlobalizado':
            obj_ = infGlobalizado.factory()
            obj_.build(child_)
            self.infGlobalizado = obj_
            obj_.original_tagname_ = 'infGlobalizado'
        elif nodeName_ == 'infServVinc':
            obj_ = infServVinc.factory()
            obj_.build(child_)
            self.infServVinc = obj_
            obj_.original_tagname_ = 'infServVinc'
# end class infCTeNorm


class infCarga(GeneratedsSuper):
    """Informações da Carga do CT-e"""
    subclass = None
    superclass = None
    def __init__(self, vCarga=None, proPred=None, xOutCat=None, infQ=None, vCargaAverb=None):
        self.original_tagname_ = None
        self.vCarga = vCarga
        self.proPred = proPred
        self.xOutCat = xOutCat
        if infQ is None:
            self.infQ = []
        else:
            self.infQ = infQ
        self.vCargaAverb = vCargaAverb
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infCarga)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infCarga.subclass:
            return infCarga.subclass(*args_, **kwargs_)
        else:
            return infCarga(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vCarga(self): return self.vCarga
    def set_vCarga(self, vCarga): self.vCarga = vCarga
    def get_proPred(self): return self.proPred
    def set_proPred(self, proPred): self.proPred = proPred
    def get_xOutCat(self): return self.xOutCat
    def set_xOutCat(self, xOutCat): self.xOutCat = xOutCat
    def get_infQ(self): return self.infQ
    def set_infQ(self, infQ): self.infQ = infQ
    def add_infQ(self, value): self.infQ.append(value)
    def insert_infQ_at(self, index, value): self.infQ.insert(index, value)
    def replace_infQ_at(self, index, value): self.infQ[index] = value
    def get_vCargaAverb(self): return self.vCargaAverb
    def set_vCargaAverb(self, vCargaAverb): self.vCargaAverb = vCargaAverb
    def hasContent_(self):
        if (
            self.vCarga is not None or
            self.proPred is not None or
            self.xOutCat is not None or
            self.infQ or
            self.vCargaAverb is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infCarga', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infCarga')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infCarga')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infCarga', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infCarga'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infCarga', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vCarga is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svCarga>%s</%svCarga>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.vCarga), input_name='vCarga')), namespace_, eol_))
        if self.proPred is not None:
            self.proPred.export(outfile, level, namespace_, name_='proPred', pretty_print=pretty_print)
        if self.xOutCat is not None:
            self.xOutCat.export(outfile, level, namespace_, name_='xOutCat', pretty_print=pretty_print)
        for infQ_ in self.infQ:
            infQ_.export(outfile, level, namespace_, name_='infQ', pretty_print=pretty_print)
        if self.vCargaAverb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svCargaAverb>%s</%svCargaAverb>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.vCargaAverb), input_name='vCargaAverb')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vCarga':
            vCarga_ = child_.text
            vCarga_ = self.gds_validate_string(vCarga_, node, 'vCarga')
            self.vCarga = vCarga_
        elif nodeName_ == 'proPred':
            obj_ = None
            self.proPred = obj_
            obj_.original_tagname_ = 'proPred'
        elif nodeName_ == 'xOutCat':
            obj_ = None
            self.xOutCat = obj_
            obj_.original_tagname_ = 'xOutCat'
        elif nodeName_ == 'infQ':
            obj_ = infQ.factory()
            obj_.build(child_)
            self.infQ.append(obj_)
            obj_.original_tagname_ = 'infQ'
        elif nodeName_ == 'vCargaAverb':
            vCargaAverb_ = child_.text
            vCargaAverb_ = self.gds_validate_string(vCargaAverb_, node, 'vCargaAverb')
            self.vCargaAverb = vCargaAverb_
# end class infCarga


class proPred(GeneratedsSuper):
    """Produto predominanteInformar a descrição do produto predominante"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, proPred)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if proPred.subclass:
            return proPred.subclass(*args_, **kwargs_)
        else:
            return proPred(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='proPred', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('proPred')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='proPred')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='proPred', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='proPred'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='proPred', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class proPred


class xOutCat(GeneratedsSuper):
    """ Outras características da carga"FRIA", "GRANEL", "REFRIGERADA",
    "Medidas: 12X12X12" """
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, xOutCat)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if xOutCat.subclass:
            return xOutCat.subclass(*args_, **kwargs_)
        else:
            return xOutCat(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='xOutCat', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('xOutCat')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='xOutCat')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='xOutCat', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='xOutCat'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='xOutCat', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class xOutCat


class infQ(GeneratedsSuper):
    """Informações de quantidades da Carga do CT-ePara o Aéreo é
    obrigatório o preenchimento desse campo da seguinte forma. 1 -
    Peso Bruto, sempre em quilogramas (obrigatório); 2 - Peso
    Cubado; sempre em quilogramas; 3 - Quantidade de volumes, sempre
    em unidades (obrigatório); 4 - Cubagem, sempre em metros cúbicos
    (obrigatório apenas quando for impossível preencher as dimensões
    da(s) embalagem(ens) na tag xDime do leiaute do Aéreo)."""
    subclass = None
    superclass = None
    def __init__(self, cUnid=None, tpMed=None, qCarga=None):
        self.original_tagname_ = None
        self.cUnid = cUnid
        self.tpMed = tpMed
        self.qCarga = qCarga
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infQ)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infQ.subclass:
            return infQ.subclass(*args_, **kwargs_)
        else:
            return infQ(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cUnid(self): return self.cUnid
    def set_cUnid(self, cUnid): self.cUnid = cUnid
    def get_tpMed(self): return self.tpMed
    def set_tpMed(self, tpMed): self.tpMed = tpMed
    def get_qCarga(self): return self.qCarga
    def set_qCarga(self, qCarga): self.qCarga = qCarga
    def hasContent_(self):
        if (
            self.cUnid is not None or
            self.tpMed is not None or
            self.qCarga is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infQ', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infQ')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infQ')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infQ', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infQ'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infQ', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cUnid is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scUnid>%s</%scUnid>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.cUnid), input_name='cUnid')), namespace_, eol_))
        if self.tpMed is not None:
            self.tpMed.export(outfile, level, namespace_, name_='tpMed', pretty_print=pretty_print)
        if self.qCarga is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sqCarga>%s</%sqCarga>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.qCarga), input_name='qCarga')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cUnid':
            cUnid_ = child_.text
            cUnid_ = self.gds_validate_string(cUnid_, node, 'cUnid')
            self.cUnid = cUnid_
        elif nodeName_ == 'tpMed':
            obj_ = None
            self.tpMed = obj_
            obj_.original_tagname_ = 'tpMed'
        elif nodeName_ == 'qCarga':
            qCarga_ = child_.text
            qCarga_ = self.gds_validate_string(qCarga_, node, 'qCarga')
            self.qCarga = qCarga_
# end class infQ


class cUnid(GeneratedsSuper):
    """Código da Unidade de Medida Preencher com: 00-M3; 01-KG; 02-TON;
    03-UNIDADE; 04-LITROS; 05-MMBTU"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cUnid)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cUnid.subclass:
            return cUnid.subclass(*args_, **kwargs_)
        else:
            return cUnid(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cUnid', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cUnid')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cUnid')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='cUnid', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cUnid'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='cUnid', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cUnid


class tpMed(GeneratedsSuper):
    """Tipo da MedidaExemplos: PESO BRUTO, PESO DECLARADO, PESO CUBADO,
    PESO AFORADO, PESO AFERIDO, PESO BASE DE CÁLCULO, LITRAGEM,
    CAIXAS e etc"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpMed)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpMed.subclass:
            return tpMed.subclass(*args_, **kwargs_)
        else:
            return tpMed(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='tpMed', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpMed')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tpMed')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='tpMed', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='tpMed'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='tpMed', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class tpMed


class infDoc(GeneratedsSuper):
    """Informações dos documentos transportados pelo CT-e Opcional para
    Redespacho Intermediario e Serviço vinculado a multimodal.Poderá
    não ser informado para os CT-e de redespacho intermediário. Nos
    demais casos deverá sempre ser informado."""
    subclass = None
    superclass = None
    def __init__(self, infNF=None, infNFe=None, infOutros=None):
        self.original_tagname_ = None
        if infNF is None:
            self.infNF = []
        else:
            self.infNF = infNF
        if infNFe is None:
            self.infNFe = []
        else:
            self.infNFe = infNFe
        if infOutros is None:
            self.infOutros = []
        else:
            self.infOutros = infOutros
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infDoc)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infDoc.subclass:
            return infDoc.subclass(*args_, **kwargs_)
        else:
            return infDoc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_infNF(self): return self.infNF
    def set_infNF(self, infNF): self.infNF = infNF
    def add_infNF(self, value): self.infNF.append(value)
    def insert_infNF_at(self, index, value): self.infNF.insert(index, value)
    def replace_infNF_at(self, index, value): self.infNF[index] = value
    def get_infNFe(self): return self.infNFe
    def set_infNFe(self, infNFe): self.infNFe = infNFe
    def add_infNFe(self, value): self.infNFe.append(value)
    def insert_infNFe_at(self, index, value): self.infNFe.insert(index, value)
    def replace_infNFe_at(self, index, value): self.infNFe[index] = value
    def get_infOutros(self): return self.infOutros
    def set_infOutros(self, infOutros): self.infOutros = infOutros
    def add_infOutros(self, value): self.infOutros.append(value)
    def insert_infOutros_at(self, index, value): self.infOutros.insert(index, value)
    def replace_infOutros_at(self, index, value): self.infOutros[index] = value
    def hasContent_(self):
        if (
            self.infNF or
            self.infNFe or
            self.infOutros
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infDoc', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infDoc')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infDoc')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infDoc', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infDoc'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infDoc', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for infNF_ in self.infNF:
            infNF_.export(outfile, level, namespace_, name_='infNF', pretty_print=pretty_print)
        for infNFe_ in self.infNFe:
            infNFe_.export(outfile, level, namespace_, name_='infNFe', pretty_print=pretty_print)
        for infOutros_ in self.infOutros:
            infOutros_.export(outfile, level, namespace_, name_='infOutros', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'infNF':
            obj_ = infNF.factory()
            obj_.build(child_)
            self.infNF.append(obj_)
            obj_.original_tagname_ = 'infNF'
        elif nodeName_ == 'infNFe':
            obj_ = infNFe.factory()
            obj_.build(child_)
            self.infNFe.append(obj_)
            obj_.original_tagname_ = 'infNFe'
        elif nodeName_ == 'infOutros':
            obj_ = infOutros.factory()
            obj_.build(child_)
            self.infOutros.append(obj_)
            obj_.original_tagname_ = 'infOutros'
# end class infDoc


class infNF(GeneratedsSuper):
    """Informações das NFEste grupo deve ser informado quando o documento
    originário for NF"""
    subclass = None
    superclass = None
    def __init__(self, nRoma=None, nPed=None, mod=None, serie=None, nDoc=None, dEmi=None, vBC=None, vICMS=None, vBCST=None, vST=None, vProd=None, vNF=None, nCFOP=None, nPeso=None, PIN=None, dPrev=None, infUnidCarga=None, infUnidTransp=None):
        self.original_tagname_ = None
        self.nRoma = nRoma
        self.nPed = nPed
        self.mod = mod
        self.serie = serie
        self.nDoc = nDoc
        self.dEmi = dEmi
        self.vBC = vBC
        self.vICMS = vICMS
        self.vBCST = vBCST
        self.vST = vST
        self.vProd = vProd
        self.vNF = vNF
        self.nCFOP = nCFOP
        self.validate_TCfop(self.nCFOP)
        self.nPeso = nPeso
        self.PIN = PIN
        self.dPrev = dPrev
        if infUnidCarga is None:
            self.infUnidCarga = []
        else:
            self.infUnidCarga = infUnidCarga
        if infUnidTransp is None:
            self.infUnidTransp = []
        else:
            self.infUnidTransp = infUnidTransp
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infNF)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infNF.subclass:
            return infNF.subclass(*args_, **kwargs_)
        else:
            return infNF(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nRoma(self): return self.nRoma
    def set_nRoma(self, nRoma): self.nRoma = nRoma
    def get_nPed(self): return self.nPed
    def set_nPed(self, nPed): self.nPed = nPed
    def get_mod(self): return self.mod
    def set_mod(self, mod): self.mod = mod
    def get_serie(self): return self.serie
    def set_serie(self, serie): self.serie = serie
    def get_nDoc(self): return self.nDoc
    def set_nDoc(self, nDoc): self.nDoc = nDoc
    def get_dEmi(self): return self.dEmi
    def set_dEmi(self, dEmi): self.dEmi = dEmi
    def get_vBC(self): return self.vBC
    def set_vBC(self, vBC): self.vBC = vBC
    def get_vICMS(self): return self.vICMS
    def set_vICMS(self, vICMS): self.vICMS = vICMS
    def get_vBCST(self): return self.vBCST
    def set_vBCST(self, vBCST): self.vBCST = vBCST
    def get_vST(self): return self.vST
    def set_vST(self, vST): self.vST = vST
    def get_vProd(self): return self.vProd
    def set_vProd(self, vProd): self.vProd = vProd
    def get_vNF(self): return self.vNF
    def set_vNF(self, vNF): self.vNF = vNF
    def get_nCFOP(self): return self.nCFOP
    def set_nCFOP(self, nCFOP): self.nCFOP = nCFOP
    def get_nPeso(self): return self.nPeso
    def set_nPeso(self, nPeso): self.nPeso = nPeso
    def get_PIN(self): return self.PIN
    def set_PIN(self, PIN): self.PIN = PIN
    def get_dPrev(self): return self.dPrev
    def set_dPrev(self, dPrev): self.dPrev = dPrev
    def get_infUnidCarga(self): return self.infUnidCarga
    def set_infUnidCarga(self, infUnidCarga): self.infUnidCarga = infUnidCarga
    def add_infUnidCarga(self, value): self.infUnidCarga.append(value)
    def insert_infUnidCarga_at(self, index, value): self.infUnidCarga.insert(index, value)
    def replace_infUnidCarga_at(self, index, value): self.infUnidCarga[index] = value
    def get_infUnidTransp(self): return self.infUnidTransp
    def set_infUnidTransp(self, infUnidTransp): self.infUnidTransp = infUnidTransp
    def add_infUnidTransp(self, value): self.infUnidTransp.append(value)
    def insert_infUnidTransp_at(self, index, value): self.infUnidTransp.insert(index, value)
    def replace_infUnidTransp_at(self, index, value): self.infUnidTransp[index] = value
    def validate_TCfop(self, value):
        # Validate type TCfop, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.nRoma is not None or
            self.nPed is not None or
            self.mod is not None or
            self.serie is not None or
            self.nDoc is not None or
            self.dEmi is not None or
            self.vBC is not None or
            self.vICMS is not None or
            self.vBCST is not None or
            self.vST is not None or
            self.vProd is not None or
            self.vNF is not None or
            self.nCFOP is not None or
            self.nPeso is not None or
            self.PIN is not None or
            self.dPrev is not None or
            self.infUnidCarga or
            self.infUnidTransp
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infNF', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infNF')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infNF')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infNF', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infNF'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infNF', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nRoma is not None:
            self.nRoma.export(outfile, level, namespace_, name_='nRoma', pretty_print=pretty_print)
        if self.nPed is not None:
            self.nPed.export(outfile, level, namespace_, name_='nPed', pretty_print=pretty_print)
        if self.mod is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smod>%s</%smod>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.mod), input_name='mod')), namespace_, eol_))
        if self.serie is not None:
            self.serie.export(outfile, level, namespace_, name_='serie', pretty_print=pretty_print)
        if self.nDoc is not None:
            self.nDoc.export(outfile, level, namespace_, name_='nDoc', pretty_print=pretty_print)
        if self.dEmi is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdEmi>%s</%sdEmi>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.dEmi), input_name='dEmi')), namespace_, eol_))
        if self.vBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBC>%s</%svBC>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.vBC), input_name='vBC')), namespace_, eol_))
        if self.vICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svICMS>%s</%svICMS>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.vICMS), input_name='vICMS')), namespace_, eol_))
        if self.vBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBCST>%s</%svBCST>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.vBCST), input_name='vBCST')), namespace_, eol_))
        if self.vST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svST>%s</%svST>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.vST), input_name='vST')), namespace_, eol_))
        if self.vProd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svProd>%s</%svProd>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.vProd), input_name='vProd')), namespace_, eol_))
        if self.vNF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svNF>%s</%svNF>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.vNF), input_name='vNF')), namespace_, eol_))
        if self.nCFOP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snCFOP>%s</%snCFOP>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.nCFOP), input_name='nCFOP')), namespace_, eol_))
        if self.nPeso is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snPeso>%s</%snPeso>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.nPeso), input_name='nPeso')), namespace_, eol_))
        if self.PIN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPIN>%s</%sPIN>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PIN), input_name='PIN')), namespace_, eol_))
        if self.dPrev is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdPrev>%s</%sdPrev>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.dPrev), input_name='dPrev')), namespace_, eol_))
        for infUnidCarga_ in self.infUnidCarga:
            infUnidCarga_.export(outfile, level, namespace_, name_='infUnidCarga', pretty_print=pretty_print)
        for infUnidTransp_ in self.infUnidTransp:
            infUnidTransp_.export(outfile, level, namespace_, name_='infUnidTransp', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nRoma':
            obj_ = None
            self.nRoma = obj_
            obj_.original_tagname_ = 'nRoma'
        elif nodeName_ == 'nPed':
            obj_ = None
            self.nPed = obj_
            obj_.original_tagname_ = 'nPed'
        elif nodeName_ == 'mod':
            mod_ = child_.text
            mod_ = self.gds_validate_string(mod_, node, 'mod')
            self.mod = mod_
        elif nodeName_ == 'serie':
            obj_ = None
            self.serie = obj_
            obj_.original_tagname_ = 'serie'
        elif nodeName_ == 'nDoc':
            obj_ = None
            self.nDoc = obj_
            obj_.original_tagname_ = 'nDoc'
        elif nodeName_ == 'dEmi':
            dEmi_ = child_.text
            dEmi_ = self.gds_validate_string(dEmi_, node, 'dEmi')
            self.dEmi = dEmi_
        elif nodeName_ == 'vBC':
            vBC_ = child_.text
            vBC_ = self.gds_validate_string(vBC_, node, 'vBC')
            self.vBC = vBC_
        elif nodeName_ == 'vICMS':
            vICMS_ = child_.text
            vICMS_ = self.gds_validate_string(vICMS_, node, 'vICMS')
            self.vICMS = vICMS_
        elif nodeName_ == 'vBCST':
            vBCST_ = child_.text
            vBCST_ = self.gds_validate_string(vBCST_, node, 'vBCST')
            self.vBCST = vBCST_
        elif nodeName_ == 'vST':
            vST_ = child_.text
            vST_ = self.gds_validate_string(vST_, node, 'vST')
            self.vST = vST_
        elif nodeName_ == 'vProd':
            vProd_ = child_.text
            vProd_ = self.gds_validate_string(vProd_, node, 'vProd')
            self.vProd = vProd_
        elif nodeName_ == 'vNF':
            vNF_ = child_.text
            vNF_ = self.gds_validate_string(vNF_, node, 'vNF')
            self.vNF = vNF_
        elif nodeName_ == 'nCFOP':
            nCFOP_ = child_.text
            nCFOP_ = self.gds_validate_string(nCFOP_, node, 'nCFOP')
            self.nCFOP = nCFOP_
            # validate type TCfop
            self.validate_TCfop(self.nCFOP)
        elif nodeName_ == 'nPeso':
            nPeso_ = child_.text
            nPeso_ = self.gds_validate_string(nPeso_, node, 'nPeso')
            self.nPeso = nPeso_
        elif nodeName_ == 'PIN':
            PIN_ = child_.text
            PIN_ = self.gds_validate_string(PIN_, node, 'PIN')
            self.PIN = PIN_
        elif nodeName_ == 'dPrev':
            dPrev_ = child_.text
            dPrev_ = self.gds_validate_string(dPrev_, node, 'dPrev')
            self.dPrev = dPrev_
        elif nodeName_ == 'infUnidCarga':
            obj_ = TUnidCarga.factory()
            obj_.build(child_)
            self.infUnidCarga.append(obj_)
            obj_.original_tagname_ = 'infUnidCarga'
        elif nodeName_ == 'infUnidTransp':
            obj_ = TUnidadeTransp.factory()
            obj_.build(child_)
            self.infUnidTransp.append(obj_)
            obj_.original_tagname_ = 'infUnidTransp'
# end class infNF


class nRoma(GeneratedsSuper):
    """Número do Romaneio da NF"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nRoma)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nRoma.subclass:
            return nRoma.subclass(*args_, **kwargs_)
        else:
            return nRoma(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='nRoma', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('nRoma')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='nRoma')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='nRoma', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='nRoma'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='nRoma', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class nRoma


class nPed(GeneratedsSuper):
    """Número do Pedido da NF"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nPed)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nPed.subclass:
            return nPed.subclass(*args_, **kwargs_)
        else:
            return nPed(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='nPed', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('nPed')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='nPed')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='nPed', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='nPed'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='nPed', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class nPed


class nDoc(GeneratedsSuper):
    """Número"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nDoc)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nDoc.subclass:
            return nDoc.subclass(*args_, **kwargs_)
        else:
            return nDoc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='nDoc', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('nDoc')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='nDoc')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='nDoc', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='nDoc'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='nDoc', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class nDoc


class PIN(GeneratedsSuper):
    """PIN SUFRAMAPIN atribuído pela SUFRAMA para a operação."""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PIN)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PIN.subclass:
            return PIN.subclass(*args_, **kwargs_)
        else:
            return PIN(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PIN', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PIN')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PIN')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PIN', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PIN'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PIN', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PIN


class infNFe(GeneratedsSuper):
    """Informações das NF-e"""
    subclass = None
    superclass = None
    def __init__(self, chave=None, PIN=None, dPrev=None, infUnidCarga=None, infUnidTransp=None):
        self.original_tagname_ = None
        self.chave = chave
        self.PIN = PIN
        self.dPrev = dPrev
        if infUnidCarga is None:
            self.infUnidCarga = []
        else:
            self.infUnidCarga = infUnidCarga
        if infUnidTransp is None:
            self.infUnidTransp = []
        else:
            self.infUnidTransp = infUnidTransp
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infNFe)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infNFe.subclass:
            return infNFe.subclass(*args_, **kwargs_)
        else:
            return infNFe(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_chave(self): return self.chave
    def set_chave(self, chave): self.chave = chave
    def get_PIN(self): return self.PIN
    def set_PIN(self, PIN): self.PIN = PIN
    def get_dPrev(self): return self.dPrev
    def set_dPrev(self, dPrev): self.dPrev = dPrev
    def get_infUnidCarga(self): return self.infUnidCarga
    def set_infUnidCarga(self, infUnidCarga): self.infUnidCarga = infUnidCarga
    def add_infUnidCarga(self, value): self.infUnidCarga.append(value)
    def insert_infUnidCarga_at(self, index, value): self.infUnidCarga.insert(index, value)
    def replace_infUnidCarga_at(self, index, value): self.infUnidCarga[index] = value
    def get_infUnidTransp(self): return self.infUnidTransp
    def set_infUnidTransp(self, infUnidTransp): self.infUnidTransp = infUnidTransp
    def add_infUnidTransp(self, value): self.infUnidTransp.append(value)
    def insert_infUnidTransp_at(self, index, value): self.infUnidTransp.insert(index, value)
    def replace_infUnidTransp_at(self, index, value): self.infUnidTransp[index] = value
    def hasContent_(self):
        if (
            self.chave is not None or
            self.PIN is not None or
            self.dPrev is not None or
            self.infUnidCarga or
            self.infUnidTransp
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infNFe', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infNFe')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infNFe')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infNFe', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infNFe'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infNFe', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.chave is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%schave>%s</%schave>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.chave), input_name='chave')), namespace_, eol_))
        if self.PIN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPIN>%s</%sPIN>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PIN), input_name='PIN')), namespace_, eol_))
        if self.dPrev is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdPrev>%s</%sdPrev>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.dPrev), input_name='dPrev')), namespace_, eol_))
        for infUnidCarga_ in self.infUnidCarga:
            infUnidCarga_.export(outfile, level, namespace_, name_='infUnidCarga', pretty_print=pretty_print)
        for infUnidTransp_ in self.infUnidTransp:
            infUnidTransp_.export(outfile, level, namespace_, name_='infUnidTransp', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'chave':
            chave_ = child_.text
            chave_ = self.gds_validate_string(chave_, node, 'chave')
            self.chave = chave_
        elif nodeName_ == 'PIN':
            PIN_ = child_.text
            PIN_ = self.gds_validate_string(PIN_, node, 'PIN')
            self.PIN = PIN_
        elif nodeName_ == 'dPrev':
            dPrev_ = child_.text
            dPrev_ = self.gds_validate_string(dPrev_, node, 'dPrev')
            self.dPrev = dPrev_
        elif nodeName_ == 'infUnidCarga':
            obj_ = TUnidCarga.factory()
            obj_.build(child_)
            self.infUnidCarga.append(obj_)
            obj_.original_tagname_ = 'infUnidCarga'
        elif nodeName_ == 'infUnidTransp':
            obj_ = TUnidadeTransp.factory()
            obj_.build(child_)
            self.infUnidTransp.append(obj_)
            obj_.original_tagname_ = 'infUnidTransp'
# end class infNFe


class infOutros(GeneratedsSuper):
    """Informações dos demais documentos"""
    subclass = None
    superclass = None
    def __init__(self, tpDoc=None, descOutros=None, nDoc=None, dEmi=None, vDocFisc=None, dPrev=None, infUnidCarga=None, infUnidTransp=None):
        self.original_tagname_ = None
        self.tpDoc = tpDoc
        self.descOutros = descOutros
        self.nDoc = nDoc
        self.dEmi = dEmi
        self.vDocFisc = vDocFisc
        self.dPrev = dPrev
        if infUnidCarga is None:
            self.infUnidCarga = []
        else:
            self.infUnidCarga = infUnidCarga
        if infUnidTransp is None:
            self.infUnidTransp = []
        else:
            self.infUnidTransp = infUnidTransp
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infOutros)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infOutros.subclass:
            return infOutros.subclass(*args_, **kwargs_)
        else:
            return infOutros(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tpDoc(self): return self.tpDoc
    def set_tpDoc(self, tpDoc): self.tpDoc = tpDoc
    def get_descOutros(self): return self.descOutros
    def set_descOutros(self, descOutros): self.descOutros = descOutros
    def get_nDoc(self): return self.nDoc
    def set_nDoc(self, nDoc): self.nDoc = nDoc
    def get_dEmi(self): return self.dEmi
    def set_dEmi(self, dEmi): self.dEmi = dEmi
    def get_vDocFisc(self): return self.vDocFisc
    def set_vDocFisc(self, vDocFisc): self.vDocFisc = vDocFisc
    def get_dPrev(self): return self.dPrev
    def set_dPrev(self, dPrev): self.dPrev = dPrev
    def get_infUnidCarga(self): return self.infUnidCarga
    def set_infUnidCarga(self, infUnidCarga): self.infUnidCarga = infUnidCarga
    def add_infUnidCarga(self, value): self.infUnidCarga.append(value)
    def insert_infUnidCarga_at(self, index, value): self.infUnidCarga.insert(index, value)
    def replace_infUnidCarga_at(self, index, value): self.infUnidCarga[index] = value
    def get_infUnidTransp(self): return self.infUnidTransp
    def set_infUnidTransp(self, infUnidTransp): self.infUnidTransp = infUnidTransp
    def add_infUnidTransp(self, value): self.infUnidTransp.append(value)
    def insert_infUnidTransp_at(self, index, value): self.infUnidTransp.insert(index, value)
    def replace_infUnidTransp_at(self, index, value): self.infUnidTransp[index] = value
    def hasContent_(self):
        if (
            self.tpDoc is not None or
            self.descOutros is not None or
            self.nDoc is not None or
            self.dEmi is not None or
            self.vDocFisc is not None or
            self.dPrev is not None or
            self.infUnidCarga or
            self.infUnidTransp
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infOutros', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infOutros')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infOutros')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infOutros', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infOutros'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infOutros', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpDoc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpDoc>%s</%stpDoc>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.tpDoc), input_name='tpDoc')), namespace_, eol_))
        if self.descOutros is not None:
            self.descOutros.export(outfile, level, namespace_, name_='descOutros', pretty_print=pretty_print)
        if self.nDoc is not None:
            self.nDoc.export(outfile, level, namespace_, name_='nDoc', pretty_print=pretty_print)
        if self.dEmi is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdEmi>%s</%sdEmi>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.dEmi), input_name='dEmi')), namespace_, eol_))
        if self.vDocFisc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svDocFisc>%s</%svDocFisc>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.vDocFisc), input_name='vDocFisc')), namespace_, eol_))
        if self.dPrev is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdPrev>%s</%sdPrev>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.dPrev), input_name='dPrev')), namespace_, eol_))
        for infUnidCarga_ in self.infUnidCarga:
            infUnidCarga_.export(outfile, level, namespace_, name_='infUnidCarga', pretty_print=pretty_print)
        for infUnidTransp_ in self.infUnidTransp:
            infUnidTransp_.export(outfile, level, namespace_, name_='infUnidTransp', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tpDoc':
            tpDoc_ = child_.text
            tpDoc_ = self.gds_validate_string(tpDoc_, node, 'tpDoc')
            self.tpDoc = tpDoc_
        elif nodeName_ == 'descOutros':
            obj_ = None
            self.descOutros = obj_
            obj_.original_tagname_ = 'descOutros'
        elif nodeName_ == 'nDoc':
            obj_ = None
            self.nDoc = obj_
            obj_.original_tagname_ = 'nDoc'
        elif nodeName_ == 'dEmi':
            dEmi_ = child_.text
            dEmi_ = self.gds_validate_string(dEmi_, node, 'dEmi')
            self.dEmi = dEmi_
        elif nodeName_ == 'vDocFisc':
            vDocFisc_ = child_.text
            vDocFisc_ = self.gds_validate_string(vDocFisc_, node, 'vDocFisc')
            self.vDocFisc = vDocFisc_
        elif nodeName_ == 'dPrev':
            dPrev_ = child_.text
            dPrev_ = self.gds_validate_string(dPrev_, node, 'dPrev')
            self.dPrev = dPrev_
        elif nodeName_ == 'infUnidCarga':
            obj_ = TUnidCarga.factory()
            obj_.build(child_)
            self.infUnidCarga.append(obj_)
            obj_.original_tagname_ = 'infUnidCarga'
        elif nodeName_ == 'infUnidTransp':
            obj_ = TUnidadeTransp.factory()
            obj_.build(child_)
            self.infUnidTransp.append(obj_)
            obj_.original_tagname_ = 'infUnidTransp'
# end class infOutros


class tpDoc(GeneratedsSuper):
    """Tipo de documento originárioPreencher com: 00 - Declaração; 10 -
    Dutoviário; 59 - CF-e SAT; 65 - NFC-e; 99 - Outros"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpDoc)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpDoc.subclass:
            return tpDoc.subclass(*args_, **kwargs_)
        else:
            return tpDoc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='tpDoc', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpDoc')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tpDoc')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='tpDoc', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='tpDoc'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='tpDoc', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class tpDoc


class descOutros(GeneratedsSuper):
    """Descrição do documento"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, descOutros)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if descOutros.subclass:
            return descOutros.subclass(*args_, **kwargs_)
        else:
            return descOutros(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='descOutros', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('descOutros')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='descOutros')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='descOutros', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='descOutros'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='descOutros', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class descOutros


class docAnt(GeneratedsSuper):
    """Documentos de Transporte Anterior"""
    subclass = None
    superclass = None
    def __init__(self, emiDocAnt=None):
        self.original_tagname_ = None
        if emiDocAnt is None:
            self.emiDocAnt = []
        else:
            self.emiDocAnt = emiDocAnt
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, docAnt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if docAnt.subclass:
            return docAnt.subclass(*args_, **kwargs_)
        else:
            return docAnt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_emiDocAnt(self): return self.emiDocAnt
    def set_emiDocAnt(self, emiDocAnt): self.emiDocAnt = emiDocAnt
    def add_emiDocAnt(self, value): self.emiDocAnt.append(value)
    def insert_emiDocAnt_at(self, index, value): self.emiDocAnt.insert(index, value)
    def replace_emiDocAnt_at(self, index, value): self.emiDocAnt[index] = value
    def hasContent_(self):
        if (
            self.emiDocAnt
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='docAnt', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('docAnt')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='docAnt')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='docAnt', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='docAnt'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='docAnt', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for emiDocAnt_ in self.emiDocAnt:
            emiDocAnt_.export(outfile, level, namespace_, name_='emiDocAnt', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'emiDocAnt':
            obj_ = emiDocAnt.factory()
            obj_.build(child_)
            self.emiDocAnt.append(obj_)
            obj_.original_tagname_ = 'emiDocAnt'
# end class docAnt


class emiDocAnt(GeneratedsSuper):
    """Emissor do documento anterior"""
    subclass = None
    superclass = None
    def __init__(self, CNPJ=None, CPF=None, IE=None, UF=None, xNome=None, idDocAnt=None):
        self.original_tagname_ = None
        self.CNPJ = CNPJ
        self.CPF = CPF
        self.IE = IE
        self.UF = UF
        self.xNome = xNome
        if idDocAnt is None:
            self.idDocAnt = []
        else:
            self.idDocAnt = idDocAnt
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, emiDocAnt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if emiDocAnt.subclass:
            return emiDocAnt.subclass(*args_, **kwargs_)
        else:
            return emiDocAnt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CNPJ(self): return self.CNPJ
    def set_CNPJ(self, CNPJ): self.CNPJ = CNPJ
    def get_CPF(self): return self.CPF
    def set_CPF(self, CPF): self.CPF = CPF
    def get_IE(self): return self.IE
    def set_IE(self, IE): self.IE = IE
    def get_UF(self): return self.UF
    def set_UF(self, UF): self.UF = UF
    def get_xNome(self): return self.xNome
    def set_xNome(self, xNome): self.xNome = xNome
    def get_idDocAnt(self): return self.idDocAnt
    def set_idDocAnt(self, idDocAnt): self.idDocAnt = idDocAnt
    def add_idDocAnt(self, value): self.idDocAnt.append(value)
    def insert_idDocAnt_at(self, index, value): self.idDocAnt.insert(index, value)
    def replace_idDocAnt_at(self, index, value): self.idDocAnt[index] = value
    def hasContent_(self):
        if (
            self.CNPJ is not None or
            self.CPF is not None or
            self.IE is not None or
            self.UF is not None or
            self.xNome is not None or
            self.idDocAnt
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='emiDocAnt', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('emiDocAnt')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='emiDocAnt')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='emiDocAnt', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='emiDocAnt'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='emiDocAnt', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CNPJ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCNPJ>%s</%sCNPJ>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CNPJ), input_name='CNPJ')), namespace_, eol_))
        if self.CPF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCPF>%s</%sCPF>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CPF), input_name='CPF')), namespace_, eol_))
        if self.IE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIE>%s</%sIE>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.IE), input_name='IE')), namespace_, eol_))
        if self.UF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUF>%s</%sUF>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.UF), input_name='UF')), namespace_, eol_))
        if self.xNome is not None:
            self.xNome.export(outfile, level, namespace_, name_='xNome', pretty_print=pretty_print)
        for idDocAnt_ in self.idDocAnt:
            idDocAnt_.export(outfile, level, namespace_, name_='idDocAnt', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CNPJ':
            CNPJ_ = child_.text
            CNPJ_ = self.gds_validate_string(CNPJ_, node, 'CNPJ')
            self.CNPJ = CNPJ_
        elif nodeName_ == 'CPF':
            CPF_ = child_.text
            CPF_ = self.gds_validate_string(CPF_, node, 'CPF')
            self.CPF = CPF_
        elif nodeName_ == 'IE':
            IE_ = child_.text
            IE_ = self.gds_validate_string(IE_, node, 'IE')
            self.IE = IE_
        elif nodeName_ == 'UF':
            UF_ = child_.text
            UF_ = self.gds_validate_string(UF_, node, 'UF')
            self.UF = UF_
        elif nodeName_ == 'xNome':
            obj_ = None
            self.xNome = obj_
            obj_.original_tagname_ = 'xNome'
        elif nodeName_ == 'idDocAnt':
            obj_ = idDocAnt.factory()
            obj_.build(child_)
            self.idDocAnt.append(obj_)
            obj_.original_tagname_ = 'idDocAnt'
# end class emiDocAnt


class idDocAnt(GeneratedsSuper):
    """Informações de identificação dos documentos de Transporte Anterior"""
    subclass = None
    superclass = None
    def __init__(self, idDocAntPap=None, idDocAntEle=None):
        self.original_tagname_ = None
        if idDocAntPap is None:
            self.idDocAntPap = []
        else:
            self.idDocAntPap = idDocAntPap
        if idDocAntEle is None:
            self.idDocAntEle = []
        else:
            self.idDocAntEle = idDocAntEle
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, idDocAnt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if idDocAnt.subclass:
            return idDocAnt.subclass(*args_, **kwargs_)
        else:
            return idDocAnt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_idDocAntPap(self): return self.idDocAntPap
    def set_idDocAntPap(self, idDocAntPap): self.idDocAntPap = idDocAntPap
    def add_idDocAntPap(self, value): self.idDocAntPap.append(value)
    def insert_idDocAntPap_at(self, index, value): self.idDocAntPap.insert(index, value)
    def replace_idDocAntPap_at(self, index, value): self.idDocAntPap[index] = value
    def get_idDocAntEle(self): return self.idDocAntEle
    def set_idDocAntEle(self, idDocAntEle): self.idDocAntEle = idDocAntEle
    def add_idDocAntEle(self, value): self.idDocAntEle.append(value)
    def insert_idDocAntEle_at(self, index, value): self.idDocAntEle.insert(index, value)
    def replace_idDocAntEle_at(self, index, value): self.idDocAntEle[index] = value
    def hasContent_(self):
        if (
            self.idDocAntPap or
            self.idDocAntEle
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='idDocAnt', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('idDocAnt')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='idDocAnt')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='idDocAnt', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='idDocAnt'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='idDocAnt', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for idDocAntPap_ in self.idDocAntPap:
            idDocAntPap_.export(outfile, level, namespace_, name_='idDocAntPap', pretty_print=pretty_print)
        for idDocAntEle_ in self.idDocAntEle:
            idDocAntEle_.export(outfile, level, namespace_, name_='idDocAntEle', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'idDocAntPap':
            obj_ = idDocAntPap.factory()
            obj_.build(child_)
            self.idDocAntPap.append(obj_)
            obj_.original_tagname_ = 'idDocAntPap'
        elif nodeName_ == 'idDocAntEle':
            obj_ = idDocAntEle.factory()
            obj_.build(child_)
            self.idDocAntEle.append(obj_)
            obj_.original_tagname_ = 'idDocAntEle'
# end class idDocAnt


class idDocAntPap(GeneratedsSuper):
    """Documentos de transporte anterior em papel"""
    subclass = None
    superclass = None
    def __init__(self, tpDoc=None, serie=None, subser=None, nDoc=None, dEmi=None):
        self.original_tagname_ = None
        self.tpDoc = tpDoc
        self.serie = serie
        self.subser = subser
        self.nDoc = nDoc
        self.dEmi = dEmi
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, idDocAntPap)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if idDocAntPap.subclass:
            return idDocAntPap.subclass(*args_, **kwargs_)
        else:
            return idDocAntPap(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tpDoc(self): return self.tpDoc
    def set_tpDoc(self, tpDoc): self.tpDoc = tpDoc
    def get_serie(self): return self.serie
    def set_serie(self, serie): self.serie = serie
    def get_subser(self): return self.subser
    def set_subser(self, subser): self.subser = subser
    def get_nDoc(self): return self.nDoc
    def set_nDoc(self, nDoc): self.nDoc = nDoc
    def get_dEmi(self): return self.dEmi
    def set_dEmi(self, dEmi): self.dEmi = dEmi
    def hasContent_(self):
        if (
            self.tpDoc is not None or
            self.serie is not None or
            self.subser is not None or
            self.nDoc is not None or
            self.dEmi is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='idDocAntPap', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('idDocAntPap')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='idDocAntPap')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='idDocAntPap', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='idDocAntPap'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='idDocAntPap', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpDoc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpDoc>%s</%stpDoc>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.tpDoc), input_name='tpDoc')), namespace_, eol_))
        if self.serie is not None:
            self.serie.export(outfile, level, namespace_, name_='serie', pretty_print=pretty_print)
        if self.subser is not None:
            self.subser.export(outfile, level, namespace_, name_='subser', pretty_print=pretty_print)
        if self.nDoc is not None:
            self.nDoc.export(outfile, level, namespace_, name_='nDoc', pretty_print=pretty_print)
        if self.dEmi is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdEmi>%s</%sdEmi>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.dEmi), input_name='dEmi')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tpDoc':
            tpDoc_ = child_.text
            tpDoc_ = self.gds_validate_string(tpDoc_, node, 'tpDoc')
            self.tpDoc = tpDoc_
        elif nodeName_ == 'serie':
            obj_ = None
            self.serie = obj_
            obj_.original_tagname_ = 'serie'
        elif nodeName_ == 'subser':
            obj_ = None
            self.subser = obj_
            obj_.original_tagname_ = 'subser'
        elif nodeName_ == 'nDoc':
            obj_ = None
            self.nDoc = obj_
            obj_.original_tagname_ = 'nDoc'
        elif nodeName_ == 'dEmi':
            dEmi_ = child_.text
            dEmi_ = self.gds_validate_string(dEmi_, node, 'dEmi')
            self.dEmi = dEmi_
# end class idDocAntPap


class subser(GeneratedsSuper):
    """Série do Documento Fiscal"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, subser)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if subser.subclass:
            return subser.subclass(*args_, **kwargs_)
        else:
            return subser(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='subser', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('subser')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='subser')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='subser', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='subser'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='subser', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class subser


class idDocAntEle(GeneratedsSuper):
    """Documentos de transporte anterior eletrônicos"""
    subclass = None
    superclass = None
    def __init__(self, chCTe=None):
        self.original_tagname_ = None
        self.chCTe = chCTe
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, idDocAntEle)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if idDocAntEle.subclass:
            return idDocAntEle.subclass(*args_, **kwargs_)
        else:
            return idDocAntEle(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_chCTe(self): return self.chCTe
    def set_chCTe(self, chCTe): self.chCTe = chCTe
    def hasContent_(self):
        if (
            self.chCTe is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='idDocAntEle', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('idDocAntEle')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='idDocAntEle')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='idDocAntEle', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='idDocAntEle'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='idDocAntEle', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.chCTe is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%schCTe>%s</%schCTe>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.chCTe), input_name='chCTe')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'chCTe':
            chCTe_ = child_.text
            chCTe_ = self.gds_validate_string(chCTe_, node, 'chCTe')
            self.chCTe = chCTe_
# end class idDocAntEle


class infModal(GeneratedsSuper):
    """Informações do modalVersão do leiaute específico para o Modal"""
    subclass = None
    superclass = None
    def __init__(self, versaoModal=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.versaoModal = _cast(None, versaoModal)
        self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infModal)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infModal.subclass:
            return infModal.subclass(*args_, **kwargs_)
        else:
            return infModal(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def get_versaoModal(self): return self.versaoModal
    def set_versaoModal(self, versaoModal): self.versaoModal = versaoModal
    def hasContent_(self):
        if (
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infModal', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infModal')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infModal')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infModal', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infModal'):
        if self.versaoModal is not None and 'versaoModal' not in already_processed:
            already_processed.add('versaoModal')
            outfile.write(' versaoModal=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.versaoModal), input_name='versaoModal')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='infModal', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('versaoModal', node)
        if value is not None and 'versaoModal' not in already_processed:
            already_processed.add('versaoModal')
            self.versaoModal = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'infModal')
        if obj_ is not None:
            self.set_anytypeobjs_(obj_)
# end class infModal


class veicNovos(GeneratedsSuper):
    """informações dos veículos transportados"""
    subclass = None
    superclass = None
    def __init__(self, chassi=None, cCor=None, xCor=None, cMod=None, vUnit=None, vFrete=None):
        self.original_tagname_ = None
        self.chassi = chassi
        self.cCor = cCor
        self.xCor = xCor
        self.cMod = cMod
        self.vUnit = vUnit
        self.vFrete = vFrete
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, veicNovos)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if veicNovos.subclass:
            return veicNovos.subclass(*args_, **kwargs_)
        else:
            return veicNovos(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_chassi(self): return self.chassi
    def set_chassi(self, chassi): self.chassi = chassi
    def get_cCor(self): return self.cCor
    def set_cCor(self, cCor): self.cCor = cCor
    def get_xCor(self): return self.xCor
    def set_xCor(self, xCor): self.xCor = xCor
    def get_cMod(self): return self.cMod
    def set_cMod(self, cMod): self.cMod = cMod
    def get_vUnit(self): return self.vUnit
    def set_vUnit(self, vUnit): self.vUnit = vUnit
    def get_vFrete(self): return self.vFrete
    def set_vFrete(self, vFrete): self.vFrete = vFrete
    def hasContent_(self):
        if (
            self.chassi is not None or
            self.cCor is not None or
            self.xCor is not None or
            self.cMod is not None or
            self.vUnit is not None or
            self.vFrete is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='veicNovos', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('veicNovos')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='veicNovos')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='veicNovos', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='veicNovos'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='veicNovos', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.chassi is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%schassi>%s</%schassi>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.chassi), input_name='chassi')), namespace_, eol_))
        if self.cCor is not None:
            self.cCor.export(outfile, level, namespace_, name_='cCor', pretty_print=pretty_print)
        if self.xCor is not None:
            self.xCor.export(outfile, level, namespace_, name_='xCor', pretty_print=pretty_print)
        if self.cMod is not None:
            self.cMod.export(outfile, level, namespace_, name_='cMod', pretty_print=pretty_print)
        if self.vUnit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svUnit>%s</%svUnit>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.vUnit), input_name='vUnit')), namespace_, eol_))
        if self.vFrete is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svFrete>%s</%svFrete>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.vFrete), input_name='vFrete')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'chassi':
            chassi_ = child_.text
            chassi_ = self.gds_validate_string(chassi_, node, 'chassi')
            self.chassi = chassi_
        elif nodeName_ == 'cCor':
            obj_ = None
            self.cCor = obj_
            obj_.original_tagname_ = 'cCor'
        elif nodeName_ == 'xCor':
            obj_ = None
            self.xCor = obj_
            obj_.original_tagname_ = 'xCor'
        elif nodeName_ == 'cMod':
            obj_ = None
            self.cMod = obj_
            obj_.original_tagname_ = 'cMod'
        elif nodeName_ == 'vUnit':
            vUnit_ = child_.text
            vUnit_ = self.gds_validate_string(vUnit_, node, 'vUnit')
            self.vUnit = vUnit_
        elif nodeName_ == 'vFrete':
            vFrete_ = child_.text
            vFrete_ = self.gds_validate_string(vFrete_, node, 'vFrete')
            self.vFrete = vFrete_
# end class veicNovos


class chassi(GeneratedsSuper):
    """Chassi do veículo"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, chassi)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if chassi.subclass:
            return chassi.subclass(*args_, **kwargs_)
        else:
            return chassi(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='chassi', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('chassi')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='chassi')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='chassi', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='chassi'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='chassi', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class chassi


class cCor(GeneratedsSuper):
    """Cor do veículoCódigo de cada montadora"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cCor)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cCor.subclass:
            return cCor.subclass(*args_, **kwargs_)
        else:
            return cCor(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cCor', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cCor')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cCor')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='cCor', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cCor'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='cCor', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cCor


class xCor(GeneratedsSuper):
    """Descrição da cor"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, xCor)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if xCor.subclass:
            return xCor.subclass(*args_, **kwargs_)
        else:
            return xCor(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='xCor', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('xCor')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='xCor')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='xCor', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='xCor'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='xCor', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class xCor


class cMod(GeneratedsSuper):
    """Código Marca ModeloUtilizar tabela RENAVAM"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cMod)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cMod.subclass:
            return cMod.subclass(*args_, **kwargs_)
        else:
            return cMod(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cMod', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cMod')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cMod')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='cMod', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cMod'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='cMod', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cMod


class cobr(GeneratedsSuper):
    """Dados da cobrança do CT-e"""
    subclass = None
    superclass = None
    def __init__(self, fat=None, dup=None):
        self.original_tagname_ = None
        self.fat = fat
        if dup is None:
            self.dup = []
        else:
            self.dup = dup
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cobr)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cobr.subclass:
            return cobr.subclass(*args_, **kwargs_)
        else:
            return cobr(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fat(self): return self.fat
    def set_fat(self, fat): self.fat = fat
    def get_dup(self): return self.dup
    def set_dup(self, dup): self.dup = dup
    def add_dup(self, value): self.dup.append(value)
    def insert_dup_at(self, index, value): self.dup.insert(index, value)
    def replace_dup_at(self, index, value): self.dup[index] = value
    def hasContent_(self):
        if (
            self.fat is not None or
            self.dup
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cobr', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cobr')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cobr')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='cobr', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cobr'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='cobr', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.fat is not None:
            self.fat.export(outfile, level, namespace_, name_='fat', pretty_print=pretty_print)
        for dup_ in self.dup:
            dup_.export(outfile, level, namespace_, name_='dup', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'fat':
            obj_ = fat.factory()
            obj_.build(child_)
            self.fat = obj_
            obj_.original_tagname_ = 'fat'
        elif nodeName_ == 'dup':
            obj_ = dup.factory()
            obj_.build(child_)
            self.dup.append(obj_)
            obj_.original_tagname_ = 'dup'
# end class cobr


class fat(GeneratedsSuper):
    """Dados da fatura"""
    subclass = None
    superclass = None
    def __init__(self, nFat=None, vOrig=None, vDesc=None, vLiq=None):
        self.original_tagname_ = None
        self.nFat = nFat
        self.vOrig = vOrig
        self.vDesc = vDesc
        self.vLiq = vLiq
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, fat)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if fat.subclass:
            return fat.subclass(*args_, **kwargs_)
        else:
            return fat(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nFat(self): return self.nFat
    def set_nFat(self, nFat): self.nFat = nFat
    def get_vOrig(self): return self.vOrig
    def set_vOrig(self, vOrig): self.vOrig = vOrig
    def get_vDesc(self): return self.vDesc
    def set_vDesc(self, vDesc): self.vDesc = vDesc
    def get_vLiq(self): return self.vLiq
    def set_vLiq(self, vLiq): self.vLiq = vLiq
    def hasContent_(self):
        if (
            self.nFat is not None or
            self.vOrig is not None or
            self.vDesc is not None or
            self.vLiq is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='fat', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('fat')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='fat')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='fat', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='fat'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='fat', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nFat is not None:
            self.nFat.export(outfile, level, namespace_, name_='nFat', pretty_print=pretty_print)
        if self.vOrig is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svOrig>%s</%svOrig>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.vOrig), input_name='vOrig')), namespace_, eol_))
        if self.vDesc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svDesc>%s</%svDesc>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.vDesc), input_name='vDesc')), namespace_, eol_))
        if self.vLiq is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svLiq>%s</%svLiq>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.vLiq), input_name='vLiq')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nFat':
            obj_ = None
            self.nFat = obj_
            obj_.original_tagname_ = 'nFat'
        elif nodeName_ == 'vOrig':
            vOrig_ = child_.text
            vOrig_ = self.gds_validate_string(vOrig_, node, 'vOrig')
            self.vOrig = vOrig_
        elif nodeName_ == 'vDesc':
            vDesc_ = child_.text
            vDesc_ = self.gds_validate_string(vDesc_, node, 'vDesc')
            self.vDesc = vDesc_
        elif nodeName_ == 'vLiq':
            vLiq_ = child_.text
            vLiq_ = self.gds_validate_string(vLiq_, node, 'vLiq')
            self.vLiq = vLiq_
# end class fat


class nFat(GeneratedsSuper):
    """Número da fatura"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nFat)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nFat.subclass:
            return nFat.subclass(*args_, **kwargs_)
        else:
            return nFat(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='nFat', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('nFat')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='nFat')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='nFat', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='nFat'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='nFat', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class nFat


class dup(GeneratedsSuper):
    """Dados das duplicatas"""
    subclass = None
    superclass = None
    def __init__(self, nDup=None, dVenc=None, vDup=None):
        self.original_tagname_ = None
        self.nDup = nDup
        self.dVenc = dVenc
        self.vDup = vDup
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, dup)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if dup.subclass:
            return dup.subclass(*args_, **kwargs_)
        else:
            return dup(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nDup(self): return self.nDup
    def set_nDup(self, nDup): self.nDup = nDup
    def get_dVenc(self): return self.dVenc
    def set_dVenc(self, dVenc): self.dVenc = dVenc
    def get_vDup(self): return self.vDup
    def set_vDup(self, vDup): self.vDup = vDup
    def hasContent_(self):
        if (
            self.nDup is not None or
            self.dVenc is not None or
            self.vDup is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='dup', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('dup')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='dup')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='dup', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='dup'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='dup', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nDup is not None:
            self.nDup.export(outfile, level, namespace_, name_='nDup', pretty_print=pretty_print)
        if self.dVenc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdVenc>%s</%sdVenc>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.dVenc), input_name='dVenc')), namespace_, eol_))
        if self.vDup is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svDup>%s</%svDup>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.vDup), input_name='vDup')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nDup':
            obj_ = None
            self.nDup = obj_
            obj_.original_tagname_ = 'nDup'
        elif nodeName_ == 'dVenc':
            dVenc_ = child_.text
            dVenc_ = self.gds_validate_string(dVenc_, node, 'dVenc')
            self.dVenc = dVenc_
        elif nodeName_ == 'vDup':
            vDup_ = child_.text
            vDup_ = self.gds_validate_string(vDup_, node, 'vDup')
            self.vDup = vDup_
# end class dup


class nDup(GeneratedsSuper):
    """Número da duplicata"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nDup)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nDup.subclass:
            return nDup.subclass(*args_, **kwargs_)
        else:
            return nDup(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='nDup', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('nDup')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='nDup')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='nDup', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='nDup'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='nDup', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class nDup


class infCteSub(GeneratedsSuper):
    """Informações do CT-e de substituição"""
    subclass = None
    superclass = None
    def __init__(self, chCte=None, refCteAnu=None, tomaICMS=None, indAlteraToma=None):
        self.original_tagname_ = None
        self.chCte = chCte
        self.refCteAnu = refCteAnu
        self.tomaICMS = tomaICMS
        self.indAlteraToma = indAlteraToma
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infCteSub)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infCteSub.subclass:
            return infCteSub.subclass(*args_, **kwargs_)
        else:
            return infCteSub(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_chCte(self): return self.chCte
    def set_chCte(self, chCte): self.chCte = chCte
    def get_refCteAnu(self): return self.refCteAnu
    def set_refCteAnu(self, refCteAnu): self.refCteAnu = refCteAnu
    def get_tomaICMS(self): return self.tomaICMS
    def set_tomaICMS(self, tomaICMS): self.tomaICMS = tomaICMS
    def get_indAlteraToma(self): return self.indAlteraToma
    def set_indAlteraToma(self, indAlteraToma): self.indAlteraToma = indAlteraToma
    def hasContent_(self):
        if (
            self.chCte is not None or
            self.refCteAnu is not None or
            self.tomaICMS is not None or
            self.indAlteraToma is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infCteSub', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infCteSub')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infCteSub')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infCteSub', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infCteSub'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infCteSub', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.chCte is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%schCte>%s</%schCte>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.chCte), input_name='chCte')), namespace_, eol_))
        if self.refCteAnu is not None:
            self.refCteAnu.export(outfile, level, namespace_, name_='refCteAnu', pretty_print=pretty_print)
        if self.tomaICMS is not None:
            self.tomaICMS.export(outfile, level, namespace_, name_='tomaICMS', pretty_print=pretty_print)
        if self.indAlteraToma is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sindAlteraToma>%s</%sindAlteraToma>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.indAlteraToma), input_name='indAlteraToma')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'chCte':
            chCte_ = child_.text
            chCte_ = self.gds_validate_string(chCte_, node, 'chCte')
            self.chCte = chCte_
        elif nodeName_ == 'refCteAnu':
            obj_ = None
            self.refCteAnu = obj_
            obj_.original_tagname_ = 'refCteAnu'
        elif nodeName_ == 'tomaICMS':
            obj_ = tomaICMS.factory()
            obj_.build(child_)
            self.tomaICMS = obj_
            obj_.original_tagname_ = 'tomaICMS'
        elif nodeName_ == 'indAlteraToma':
            indAlteraToma_ = child_.text
            indAlteraToma_ = self.gds_validate_string(indAlteraToma_, node, 'indAlteraToma')
            self.indAlteraToma = indAlteraToma_
# end class infCteSub


class chCte(GeneratedsSuper):
    """Chave de acesso do CT-e a ser substituído (original)"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, chCte)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if chCte.subclass:
            return chCte.subclass(*args_, **kwargs_)
        else:
            return chCte(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='chCte', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('chCte')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='chCte')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='chCte', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='chCte'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='chCte', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class chCte


class refCteAnu(GeneratedsSuper):
    """Chave de acesso do CT-e de Anulação"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, refCteAnu)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if refCteAnu.subclass:
            return refCteAnu.subclass(*args_, **kwargs_)
        else:
            return refCteAnu(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='refCteAnu', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('refCteAnu')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='refCteAnu')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='refCteAnu', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='refCteAnu'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='refCteAnu', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class refCteAnu


class tomaICMS(GeneratedsSuper):
    """Tomador é contribuinte do ICMS, mas não é emitente de documento
    fiscal eletrônico"""
    subclass = None
    superclass = None
    def __init__(self, refNFe=None, refNF=None, refCte=None):
        self.original_tagname_ = None
        self.refNFe = refNFe
        self.refNF = refNF
        self.refCte = refCte
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tomaICMS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tomaICMS.subclass:
            return tomaICMS.subclass(*args_, **kwargs_)
        else:
            return tomaICMS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_refNFe(self): return self.refNFe
    def set_refNFe(self, refNFe): self.refNFe = refNFe
    def get_refNF(self): return self.refNF
    def set_refNF(self, refNF): self.refNF = refNF
    def get_refCte(self): return self.refCte
    def set_refCte(self, refCte): self.refCte = refCte
    def hasContent_(self):
        if (
            self.refNFe is not None or
            self.refNF is not None or
            self.refCte is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='tomaICMS', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tomaICMS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tomaICMS')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='tomaICMS', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='tomaICMS'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='tomaICMS', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.refNFe is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srefNFe>%s</%srefNFe>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.refNFe), input_name='refNFe')), namespace_, eol_))
        if self.refNF is not None:
            self.refNF.export(outfile, level, namespace_, name_='refNF', pretty_print=pretty_print)
        if self.refCte is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srefCte>%s</%srefCte>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.refCte), input_name='refCte')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'refNFe':
            refNFe_ = child_.text
            refNFe_ = self.gds_validate_string(refNFe_, node, 'refNFe')
            self.refNFe = refNFe_
        elif nodeName_ == 'refNF':
            obj_ = refNF.factory()
            obj_.build(child_)
            self.refNF = obj_
            obj_.original_tagname_ = 'refNF'
        elif nodeName_ == 'refCte':
            refCte_ = child_.text
            refCte_ = self.gds_validate_string(refCte_, node, 'refCte')
            self.refCte = refCte_
# end class tomaICMS


class refNF(GeneratedsSuper):
    """Informação da NF ou CT emitido pelo Tomador"""
    subclass = None
    superclass = None
    def __init__(self, CNPJ=None, CPF=None, mod=None, serie=None, subserie=None, nro=None, valor=None, dEmi=None):
        self.original_tagname_ = None
        self.CNPJ = CNPJ
        self.CPF = CPF
        self.mod = mod
        self.validate_TModDoc(self.mod)
        self.serie = serie
        self.subserie = subserie
        self.nro = nro
        self.valor = valor
        self.dEmi = dEmi
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, refNF)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if refNF.subclass:
            return refNF.subclass(*args_, **kwargs_)
        else:
            return refNF(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CNPJ(self): return self.CNPJ
    def set_CNPJ(self, CNPJ): self.CNPJ = CNPJ
    def get_CPF(self): return self.CPF
    def set_CPF(self, CPF): self.CPF = CPF
    def get_mod(self): return self.mod
    def set_mod(self, mod): self.mod = mod
    def get_serie(self): return self.serie
    def set_serie(self, serie): self.serie = serie
    def get_subserie(self): return self.subserie
    def set_subserie(self, subserie): self.subserie = subserie
    def get_nro(self): return self.nro
    def set_nro(self, nro): self.nro = nro
    def get_valor(self): return self.valor
    def set_valor(self, valor): self.valor = valor
    def get_dEmi(self): return self.dEmi
    def set_dEmi(self, dEmi): self.dEmi = dEmi
    def validate_TModDoc(self, value):
        # Validate type TModDoc, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.CNPJ is not None or
            self.CPF is not None or
            self.mod is not None or
            self.serie is not None or
            self.subserie is not None or
            self.nro is not None or
            self.valor is not None or
            self.dEmi is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='refNF', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('refNF')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='refNF')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='refNF', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='refNF'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='refNF', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CNPJ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCNPJ>%s</%sCNPJ>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CNPJ), input_name='CNPJ')), namespace_, eol_))
        if self.CPF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCPF>%s</%sCPF>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CPF), input_name='CPF')), namespace_, eol_))
        if self.mod is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smod>%s</%smod>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.mod), input_name='mod')), namespace_, eol_))
        if self.serie is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sserie>%s</%sserie>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.serie), input_name='serie')), namespace_, eol_))
        if self.subserie is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssubserie>%s</%ssubserie>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.subserie), input_name='subserie')), namespace_, eol_))
        if self.nro is not None:
            self.nro.export(outfile, level, namespace_, name_='nro', pretty_print=pretty_print)
        if self.valor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalor>%s</%svalor>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.valor), input_name='valor')), namespace_, eol_))
        if self.dEmi is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdEmi>%s</%sdEmi>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.dEmi), input_name='dEmi')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CNPJ':
            CNPJ_ = child_.text
            CNPJ_ = self.gds_validate_string(CNPJ_, node, 'CNPJ')
            self.CNPJ = CNPJ_
        elif nodeName_ == 'CPF':
            CPF_ = child_.text
            CPF_ = self.gds_validate_string(CPF_, node, 'CPF')
            self.CPF = CPF_
        elif nodeName_ == 'mod':
            mod_ = child_.text
            mod_ = self.gds_validate_string(mod_, node, 'mod')
            self.mod = mod_
            # validate type TModDoc
            self.validate_TModDoc(self.mod)
        elif nodeName_ == 'serie':
            serie_ = child_.text
            serie_ = self.gds_validate_string(serie_, node, 'serie')
            self.serie = serie_
        elif nodeName_ == 'subserie':
            subserie_ = child_.text
            subserie_ = self.gds_validate_string(subserie_, node, 'subserie')
            self.subserie = subserie_
        elif nodeName_ == 'nro':
            obj_ = None
            self.nro = obj_
            obj_.original_tagname_ = 'nro'
        elif nodeName_ == 'valor':
            valor_ = child_.text
            valor_ = self.gds_validate_string(valor_, node, 'valor')
            self.valor = valor_
        elif nodeName_ == 'dEmi':
            dEmi_ = child_.text
            dEmi_ = self.gds_validate_string(dEmi_, node, 'dEmi')
            self.dEmi = dEmi_
# end class refNF


class nro(GeneratedsSuper):
    """Número do documento fiscal"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nro)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nro.subclass:
            return nro.subclass(*args_, **kwargs_)
        else:
            return nro(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='nro', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('nro')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='nro')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='nro', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='nro'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='nro', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class nro


class indAlteraToma(GeneratedsSuper):
    """Indicador de CT-e Alteração de TomadorTag com efeito e utilização
    aguardando legislação, não utilizar antes de NT específica
    tratar desse procedimento"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, indAlteraToma)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if indAlteraToma.subclass:
            return indAlteraToma.subclass(*args_, **kwargs_)
        else:
            return indAlteraToma(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='indAlteraToma', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('indAlteraToma')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='indAlteraToma')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='indAlteraToma', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='indAlteraToma'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='indAlteraToma', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class indAlteraToma


class infGlobalizado(GeneratedsSuper):
    """Informações do CT-e Globalizado"""
    subclass = None
    superclass = None
    def __init__(self, xObs=None):
        self.original_tagname_ = None
        self.xObs = xObs
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infGlobalizado)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infGlobalizado.subclass:
            return infGlobalizado.subclass(*args_, **kwargs_)
        else:
            return infGlobalizado(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_xObs(self): return self.xObs
    def set_xObs(self, xObs): self.xObs = xObs
    def hasContent_(self):
        if (
            self.xObs is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infGlobalizado', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infGlobalizado')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infGlobalizado')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infGlobalizado', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infGlobalizado'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infGlobalizado', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.xObs is not None:
            self.xObs.export(outfile, level, namespace_, name_='xObs', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'xObs':
            obj_ = None
            self.xObs = obj_
            obj_.original_tagname_ = 'xObs'
# end class infGlobalizado


class infServVinc(GeneratedsSuper):
    """Informações do Serviço Vinculado a Multimodal"""
    subclass = None
    superclass = None
    def __init__(self, infCTeMultimodal=None):
        self.original_tagname_ = None
        if infCTeMultimodal is None:
            self.infCTeMultimodal = []
        else:
            self.infCTeMultimodal = infCTeMultimodal
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infServVinc)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infServVinc.subclass:
            return infServVinc.subclass(*args_, **kwargs_)
        else:
            return infServVinc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_infCTeMultimodal(self): return self.infCTeMultimodal
    def set_infCTeMultimodal(self, infCTeMultimodal): self.infCTeMultimodal = infCTeMultimodal
    def add_infCTeMultimodal(self, value): self.infCTeMultimodal.append(value)
    def insert_infCTeMultimodal_at(self, index, value): self.infCTeMultimodal.insert(index, value)
    def replace_infCTeMultimodal_at(self, index, value): self.infCTeMultimodal[index] = value
    def hasContent_(self):
        if (
            self.infCTeMultimodal
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infServVinc', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infServVinc')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infServVinc')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infServVinc', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infServVinc'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infServVinc', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for infCTeMultimodal_ in self.infCTeMultimodal:
            infCTeMultimodal_.export(outfile, level, namespace_, name_='infCTeMultimodal', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'infCTeMultimodal':
            obj_ = infCTeMultimodal.factory()
            obj_.build(child_)
            self.infCTeMultimodal.append(obj_)
            obj_.original_tagname_ = 'infCTeMultimodal'
# end class infServVinc


class infCTeMultimodal(GeneratedsSuper):
    """informações do CT-e multimodal vinculado"""
    subclass = None
    superclass = None
    def __init__(self, chCTeMultimodal=None):
        self.original_tagname_ = None
        self.chCTeMultimodal = chCTeMultimodal
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infCTeMultimodal)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infCTeMultimodal.subclass:
            return infCTeMultimodal.subclass(*args_, **kwargs_)
        else:
            return infCTeMultimodal(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_chCTeMultimodal(self): return self.chCTeMultimodal
    def set_chCTeMultimodal(self, chCTeMultimodal): self.chCTeMultimodal = chCTeMultimodal
    def hasContent_(self):
        if (
            self.chCTeMultimodal is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infCTeMultimodal', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infCTeMultimodal')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infCTeMultimodal')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infCTeMultimodal', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infCTeMultimodal'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infCTeMultimodal', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.chCTeMultimodal is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%schCTeMultimodal>%s</%schCTeMultimodal>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.chCTeMultimodal), input_name='chCTeMultimodal')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'chCTeMultimodal':
            chCTeMultimodal_ = child_.text
            chCTeMultimodal_ = self.gds_validate_string(chCTeMultimodal_, node, 'chCTeMultimodal')
            self.chCTeMultimodal = chCTeMultimodal_
# end class infCTeMultimodal


class infCteComp(GeneratedsSuper):
    """Detalhamento do CT-e complementado"""
    subclass = None
    superclass = None
    def __init__(self, chCTe=None):
        self.original_tagname_ = None
        self.chCTe = chCTe
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infCteComp)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infCteComp.subclass:
            return infCteComp.subclass(*args_, **kwargs_)
        else:
            return infCteComp(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_chCTe(self): return self.chCTe
    def set_chCTe(self, chCTe): self.chCTe = chCTe
    def hasContent_(self):
        if (
            self.chCTe is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infCteComp', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infCteComp')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infCteComp')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infCteComp', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infCteComp'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infCteComp', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.chCTe is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%schCTe>%s</%schCTe>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.chCTe), input_name='chCTe')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'chCTe':
            chCTe_ = child_.text
            chCTe_ = self.gds_validate_string(chCTe_, node, 'chCTe')
            self.chCTe = chCTe_
# end class infCteComp


class infCteAnu(GeneratedsSuper):
    """Detalhamento do CT-e do tipo Anulação"""
    subclass = None
    superclass = None
    def __init__(self, chCte=None, dEmi=None):
        self.original_tagname_ = None
        self.chCte = chCte
        self.dEmi = dEmi
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infCteAnu)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infCteAnu.subclass:
            return infCteAnu.subclass(*args_, **kwargs_)
        else:
            return infCteAnu(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_chCte(self): return self.chCte
    def set_chCte(self, chCte): self.chCte = chCte
    def get_dEmi(self): return self.dEmi
    def set_dEmi(self, dEmi): self.dEmi = dEmi
    def hasContent_(self):
        if (
            self.chCte is not None or
            self.dEmi is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infCteAnu', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infCteAnu')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infCteAnu')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infCteAnu', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infCteAnu'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infCteAnu', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.chCte is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%schCte>%s</%schCte>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.chCte), input_name='chCte')), namespace_, eol_))
        if self.dEmi is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdEmi>%s</%sdEmi>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.dEmi), input_name='dEmi')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'chCte':
            chCte_ = child_.text
            chCte_ = self.gds_validate_string(chCte_, node, 'chCte')
            self.chCte = chCte_
        elif nodeName_ == 'dEmi':
            dEmi_ = child_.text
            dEmi_ = self.gds_validate_string(dEmi_, node, 'dEmi')
            self.dEmi = dEmi_
# end class infCteAnu


class autXML(GeneratedsSuper):
    """Autorizados para download do XML do DF-eInformar CNPJ ou CPF.
    Preencher os zeros não significativos."""
    subclass = None
    superclass = None
    def __init__(self, CNPJ=None, CPF=None):
        self.original_tagname_ = None
        self.CNPJ = CNPJ
        self.CPF = CPF
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, autXML)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if autXML.subclass:
            return autXML.subclass(*args_, **kwargs_)
        else:
            return autXML(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CNPJ(self): return self.CNPJ
    def set_CNPJ(self, CNPJ): self.CNPJ = CNPJ
    def get_CPF(self): return self.CPF
    def set_CPF(self, CPF): self.CPF = CPF
    def hasContent_(self):
        if (
            self.CNPJ is not None or
            self.CPF is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='autXML', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('autXML')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='autXML')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='autXML', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='autXML'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='autXML', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CNPJ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCNPJ>%s</%sCNPJ>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CNPJ), input_name='CNPJ')), namespace_, eol_))
        if self.CPF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCPF>%s</%sCPF>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CPF), input_name='CPF')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CNPJ':
            CNPJ_ = child_.text
            CNPJ_ = self.gds_validate_string(CNPJ_, node, 'CNPJ')
            self.CNPJ = CNPJ_
        elif nodeName_ == 'CPF':
            CPF_ = child_.text
            CPF_ = self.gds_validate_string(CPF_, node, 'CPF')
            self.CPF = CPF_
# end class autXML


class TCTeOS(GeneratedsSuper):
    """Tipo Conhecimento de Transporte Eletrônico Outros Serviços (Modelo
    67)Versão do leiaute"""
    subclass = None
    superclass = None
    def __init__(self, versao=None, infCte=None, Signature=None):
        self.original_tagname_ = None
        self.versao = _cast(None, versao)
        self.infCte = infCte
        self.Signature = Signature
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TCTeOS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TCTeOS.subclass:
            return TCTeOS.subclass(*args_, **kwargs_)
        else:
            return TCTeOS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_infCte(self): return self.infCte
    def set_infCte(self, infCte): self.infCte = infCte
    def get_Signature(self): return self.Signature
    def set_Signature(self, Signature): self.Signature = Signature
    def get_versao(self): return self.versao
    def set_versao(self, versao): self.versao = versao
    def validate_TVerCTe(self, value):
        # Validate type TVerCTe, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.infCte is not None or
            self.Signature is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TCTeOS', namespacedef_=' xmlns:ds="http://www.w3.org/2000/09/xmldsig#" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TCTeOS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TCTeOS')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TCTeOS', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TCTeOS'):
        if self.versao is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            outfile.write(' versao=%s' % (quote_attrib(self.versao), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TCTeOS', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.infCte is not None:
            self.infCte.export(outfile, level, namespace_, name_='infCte', pretty_print=pretty_print)
        if self.Signature is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSignature>%s</%sSignature>%s' % ('ds:', self.gds_encode(self.gds_format_string(quote_xml(self.Signature), input_name='Signature')), 'ds:', eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('versao', node)
        if value is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            self.versao = value
            self.validate_TVerCTe(self.versao)    # validate type TVerCTe
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'infCte':
            obj_ = infCte.factory()
            obj_.build(child_)
            self.infCte = obj_
            obj_.original_tagname_ = 'infCte'
        elif nodeName_ == 'Signature':
            Signature_ = child_.text
            Signature_ = self.gds_validate_string(Signature_, node, 'Signature')
            self.Signature = Signature_
# end class TCTeOS


class infPercurso(GeneratedsSuper):
    """Informações do Percurso do CT-e Outros Serviços"""
    subclass = None
    superclass = None
    def __init__(self, UFPer=None):
        self.original_tagname_ = None
        self.UFPer = UFPer
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infPercurso)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infPercurso.subclass:
            return infPercurso.subclass(*args_, **kwargs_)
        else:
            return infPercurso(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_UFPer(self): return self.UFPer
    def set_UFPer(self, UFPer): self.UFPer = UFPer
    def hasContent_(self):
        if (
            self.UFPer is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infPercurso', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infPercurso')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infPercurso')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infPercurso', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infPercurso'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infPercurso', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.UFPer is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUFPer>%s</%sUFPer>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.UFPer), input_name='UFPer')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'UFPer':
            UFPer_ = child_.text
            UFPer_ = self.gds_validate_string(UFPer_, node, 'UFPer')
            self.UFPer = UFPer_
# end class infPercurso


class infTribFed(GeneratedsSuper):
    """Informações dos tributos federaisGrupo a ser informado nas
    prestações interestaduais para consumidor final, não
    contribuinte do ICMS"""
    subclass = None
    superclass = None
    def __init__(self, vPIS=None, vCOFINS=None, vIR=None, vINSS=None, vCSLL=None):
        self.original_tagname_ = None
        self.vPIS = vPIS
        self.vCOFINS = vCOFINS
        self.vIR = vIR
        self.vINSS = vINSS
        self.vCSLL = vCSLL
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infTribFed)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infTribFed.subclass:
            return infTribFed.subclass(*args_, **kwargs_)
        else:
            return infTribFed(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vPIS(self): return self.vPIS
    def set_vPIS(self, vPIS): self.vPIS = vPIS
    def get_vCOFINS(self): return self.vCOFINS
    def set_vCOFINS(self, vCOFINS): self.vCOFINS = vCOFINS
    def get_vIR(self): return self.vIR
    def set_vIR(self, vIR): self.vIR = vIR
    def get_vINSS(self): return self.vINSS
    def set_vINSS(self, vINSS): self.vINSS = vINSS
    def get_vCSLL(self): return self.vCSLL
    def set_vCSLL(self, vCSLL): self.vCSLL = vCSLL
    def hasContent_(self):
        if (
            self.vPIS is not None or
            self.vCOFINS is not None or
            self.vIR is not None or
            self.vINSS is not None or
            self.vCSLL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infTribFed', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infTribFed')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infTribFed')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infTribFed', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infTribFed'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infTribFed', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vPIS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svPIS>%s</%svPIS>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.vPIS), input_name='vPIS')), namespace_, eol_))
        if self.vCOFINS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svCOFINS>%s</%svCOFINS>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.vCOFINS), input_name='vCOFINS')), namespace_, eol_))
        if self.vIR is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svIR>%s</%svIR>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.vIR), input_name='vIR')), namespace_, eol_))
        if self.vINSS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svINSS>%s</%svINSS>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.vINSS), input_name='vINSS')), namespace_, eol_))
        if self.vCSLL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svCSLL>%s</%svCSLL>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.vCSLL), input_name='vCSLL')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vPIS':
            vPIS_ = child_.text
            vPIS_ = self.gds_validate_string(vPIS_, node, 'vPIS')
            self.vPIS = vPIS_
        elif nodeName_ == 'vCOFINS':
            vCOFINS_ = child_.text
            vCOFINS_ = self.gds_validate_string(vCOFINS_, node, 'vCOFINS')
            self.vCOFINS = vCOFINS_
        elif nodeName_ == 'vIR':
            vIR_ = child_.text
            vIR_ = self.gds_validate_string(vIR_, node, 'vIR')
            self.vIR = vIR_
        elif nodeName_ == 'vINSS':
            vINSS_ = child_.text
            vINSS_ = self.gds_validate_string(vINSS_, node, 'vINSS')
            self.vINSS = vINSS_
        elif nodeName_ == 'vCSLL':
            vCSLL_ = child_.text
            vCSLL_ = self.gds_validate_string(vCSLL_, node, 'vCSLL')
            self.vCSLL = vCSLL_
# end class infTribFed


class infServico(GeneratedsSuper):
    """Informações da Prestação do Serviço"""
    subclass = None
    superclass = None
    def __init__(self, xDescServ=None, infQ=None):
        self.original_tagname_ = None
        self.xDescServ = xDescServ
        self.infQ = infQ
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infServico)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infServico.subclass:
            return infServico.subclass(*args_, **kwargs_)
        else:
            return infServico(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_xDescServ(self): return self.xDescServ
    def set_xDescServ(self, xDescServ): self.xDescServ = xDescServ
    def get_infQ(self): return self.infQ
    def set_infQ(self, infQ): self.infQ = infQ
    def hasContent_(self):
        if (
            self.xDescServ is not None or
            self.infQ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infServico', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infServico')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infServico')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infServico', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infServico'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infServico', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.xDescServ is not None:
            self.xDescServ.export(outfile, level, namespace_, name_='xDescServ', pretty_print=pretty_print)
        if self.infQ is not None:
            self.infQ.export(outfile, level, namespace_, name_='infQ', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'xDescServ':
            obj_ = None
            self.xDescServ = obj_
            obj_.original_tagname_ = 'xDescServ'
        elif nodeName_ == 'infQ':
            obj_ = infQ.factory()
            obj_.build(child_)
            self.infQ = obj_
            obj_.original_tagname_ = 'infQ'
# end class infServico


class xDescServ(GeneratedsSuper):
    """Descrição do Serviço prestado"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, xDescServ)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if xDescServ.subclass:
            return xDescServ.subclass(*args_, **kwargs_)
        else:
            return xDescServ(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='xDescServ', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('xDescServ')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='xDescServ')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='xDescServ', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='xDescServ'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='xDescServ', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class xDescServ


class infDocRef(GeneratedsSuper):
    """Informações dos documentos referenciados"""
    subclass = None
    superclass = None
    def __init__(self, nDoc=None, serie=None, subserie=None, dEmi=None, vDoc=None):
        self.original_tagname_ = None
        self.nDoc = nDoc
        self.serie = serie
        self.subserie = subserie
        self.dEmi = dEmi
        self.vDoc = vDoc
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infDocRef)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infDocRef.subclass:
            return infDocRef.subclass(*args_, **kwargs_)
        else:
            return infDocRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nDoc(self): return self.nDoc
    def set_nDoc(self, nDoc): self.nDoc = nDoc
    def get_serie(self): return self.serie
    def set_serie(self, serie): self.serie = serie
    def get_subserie(self): return self.subserie
    def set_subserie(self, subserie): self.subserie = subserie
    def get_dEmi(self): return self.dEmi
    def set_dEmi(self, dEmi): self.dEmi = dEmi
    def get_vDoc(self): return self.vDoc
    def set_vDoc(self, vDoc): self.vDoc = vDoc
    def hasContent_(self):
        if (
            self.nDoc is not None or
            self.serie is not None or
            self.subserie is not None or
            self.dEmi is not None or
            self.vDoc is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infDocRef', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infDocRef')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infDocRef')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infDocRef', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infDocRef'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infDocRef', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nDoc is not None:
            self.nDoc.export(outfile, level, namespace_, name_='nDoc', pretty_print=pretty_print)
        if self.serie is not None:
            self.serie.export(outfile, level, namespace_, name_='serie', pretty_print=pretty_print)
        if self.subserie is not None:
            self.subserie.export(outfile, level, namespace_, name_='subserie', pretty_print=pretty_print)
        if self.dEmi is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdEmi>%s</%sdEmi>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.dEmi), input_name='dEmi')), namespace_, eol_))
        if self.vDoc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svDoc>%s</%svDoc>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.vDoc), input_name='vDoc')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nDoc':
            obj_ = None
            self.nDoc = obj_
            obj_.original_tagname_ = 'nDoc'
        elif nodeName_ == 'serie':
            obj_ = None
            self.serie = obj_
            obj_.original_tagname_ = 'serie'
        elif nodeName_ == 'subserie':
            obj_ = None
            self.subserie = obj_
            obj_.original_tagname_ = 'subserie'
        elif nodeName_ == 'dEmi':
            dEmi_ = child_.text
            dEmi_ = self.gds_validate_string(dEmi_, node, 'dEmi')
            self.dEmi = dEmi_
        elif nodeName_ == 'vDoc':
            vDoc_ = child_.text
            vDoc_ = self.gds_validate_string(vDoc_, node, 'vDoc')
            self.vDoc = vDoc_
# end class infDocRef


class subserie(GeneratedsSuper):
    """Subsérie"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, subserie)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if subserie.subclass:
            return subserie.subclass(*args_, **kwargs_)
        else:
            return subserie(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='subserie', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('subserie')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='subserie')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='subserie', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='subserie'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='subserie', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class subserie


class seg(GeneratedsSuper):
    """Informações de Seguro da Carga"""
    subclass = None
    superclass = None
    def __init__(self, respSeg=None, xSeg=None, nApol=None):
        self.original_tagname_ = None
        self.respSeg = respSeg
        self.xSeg = xSeg
        self.nApol = nApol
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, seg)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if seg.subclass:
            return seg.subclass(*args_, **kwargs_)
        else:
            return seg(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_respSeg(self): return self.respSeg
    def set_respSeg(self, respSeg): self.respSeg = respSeg
    def get_xSeg(self): return self.xSeg
    def set_xSeg(self, xSeg): self.xSeg = xSeg
    def get_nApol(self): return self.nApol
    def set_nApol(self, nApol): self.nApol = nApol
    def hasContent_(self):
        if (
            self.respSeg is not None or
            self.xSeg is not None or
            self.nApol is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='seg', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('seg')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='seg')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='seg', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='seg'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='seg', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.respSeg is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srespSeg>%s</%srespSeg>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.respSeg), input_name='respSeg')), namespace_, eol_))
        if self.xSeg is not None:
            self.xSeg.export(outfile, level, namespace_, name_='xSeg', pretty_print=pretty_print)
        if self.nApol is not None:
            self.nApol.export(outfile, level, namespace_, name_='nApol', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'respSeg':
            respSeg_ = child_.text
            respSeg_ = self.gds_validate_string(respSeg_, node, 'respSeg')
            self.respSeg = respSeg_
        elif nodeName_ == 'xSeg':
            obj_ = None
            self.xSeg = obj_
            obj_.original_tagname_ = 'xSeg'
        elif nodeName_ == 'nApol':
            obj_ = None
            self.nApol = obj_
            obj_.original_tagname_ = 'nApol'
# end class seg


class respSeg(GeneratedsSuper):
    """Responsável pelo seguroPreencher com: 4 - Emitente do CT-e; 5 -
    Tomador de Serviço."""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, respSeg)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if respSeg.subclass:
            return respSeg.subclass(*args_, **kwargs_)
        else:
            return respSeg(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='respSeg', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('respSeg')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='respSeg')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='respSeg', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='respSeg'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='respSeg', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class respSeg


class xSeg(GeneratedsSuper):
    """Nome da Seguradora"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, xSeg)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if xSeg.subclass:
            return xSeg.subclass(*args_, **kwargs_)
        else:
            return xSeg(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='xSeg', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('xSeg')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='xSeg')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='xSeg', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='xSeg'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='xSeg', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class xSeg


class nApol(GeneratedsSuper):
    """Número da ApóliceObrigatório pela lei 11.442/07 (RCTRC)"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nApol)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nApol.subclass:
            return nApol.subclass(*args_, **kwargs_)
        else:
            return nApol(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='nApol', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('nApol')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='nApol')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='nApol', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='nApol'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='nApol', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class nApol


class refCTeCanc(GeneratedsSuper):
    """Chave de acesso do CT-e Cancelado Somente para Transporte de Valores"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, refCTeCanc)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if refCTeCanc.subclass:
            return refCTeCanc.subclass(*args_, **kwargs_)
        else:
            return refCTeCanc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='refCTeCanc', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('refCTeCanc')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='refCTeCanc')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='refCTeCanc', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='refCTeCanc'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='refCTeCanc', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class refCTeCanc


class TEnviCTe(GeneratedsSuper):
    """Tipo Pedido de Concessão de Autorização da CT-e"""
    subclass = None
    superclass = None
    def __init__(self, versao=None, idLote=None, CTe=None):
        self.original_tagname_ = None
        self.versao = _cast(None, versao)
        self.idLote = idLote
        self.validate_TIdLote(self.idLote)
        if CTe is None:
            self.CTe = []
        else:
            self.CTe = CTe
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TEnviCTe)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TEnviCTe.subclass:
            return TEnviCTe.subclass(*args_, **kwargs_)
        else:
            return TEnviCTe(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_idLote(self): return self.idLote
    def set_idLote(self, idLote): self.idLote = idLote
    def get_CTe(self): return self.CTe
    def set_CTe(self, CTe): self.CTe = CTe
    def add_CTe(self, value): self.CTe.append(value)
    def insert_CTe_at(self, index, value): self.CTe.insert(index, value)
    def replace_CTe_at(self, index, value): self.CTe[index] = value
    def get_versao(self): return self.versao
    def set_versao(self, versao): self.versao = versao
    def validate_TIdLote(self, value):
        # Validate type TIdLote, a restriction on xs:string.
        pass
    def validate_TVerCTe(self, value):
        # Validate type TVerCTe, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.idLote is not None or
            self.CTe
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TEnviCTe', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TEnviCTe')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TEnviCTe')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TEnviCTe', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TEnviCTe'):
        if self.versao is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            outfile.write(' versao=%s' % (quote_attrib(self.versao), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TEnviCTe', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.idLote is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sidLote>%s</%sidLote>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.idLote), input_name='idLote')), namespace_, eol_))
        for CTe_ in self.CTe:
            CTe_.export(outfile, level, namespace_, name_='CTe', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('versao', node)
        if value is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            self.versao = value
            self.validate_TVerCTe(self.versao)    # validate type TVerCTe
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'idLote':
            idLote_ = child_.text
            idLote_ = self.gds_validate_string(idLote_, node, 'idLote')
            self.idLote = idLote_
            # validate type TIdLote
            self.validate_TIdLote(self.idLote)
        elif nodeName_ == 'CTe':
            obj_ = TCTe.factory()
            obj_.build(child_)
            self.CTe.append(obj_)
            obj_.original_tagname_ = 'CTe'
# end class TEnviCTe


class TRetEnviCTe(GeneratedsSuper):
    """Tipo Retorno do Pedido de Concessão de Autorização da CT-e"""
    subclass = None
    superclass = None
    def __init__(self, versao=None, tpAmb=None, cUF=None, verAplic=None, cStat=None, xMotivo=None, infRec=None):
        self.original_tagname_ = None
        self.versao = _cast(None, versao)
        self.tpAmb = tpAmb
        self.cUF = cUF
        self.verAplic = verAplic
        self.cStat = cStat
        self.xMotivo = xMotivo
        self.infRec = infRec
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TRetEnviCTe)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TRetEnviCTe.subclass:
            return TRetEnviCTe.subclass(*args_, **kwargs_)
        else:
            return TRetEnviCTe(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tpAmb(self): return self.tpAmb
    def set_tpAmb(self, tpAmb): self.tpAmb = tpAmb
    def get_cUF(self): return self.cUF
    def set_cUF(self, cUF): self.cUF = cUF
    def get_verAplic(self): return self.verAplic
    def set_verAplic(self, verAplic): self.verAplic = verAplic
    def get_cStat(self): return self.cStat
    def set_cStat(self, cStat): self.cStat = cStat
    def get_xMotivo(self): return self.xMotivo
    def set_xMotivo(self, xMotivo): self.xMotivo = xMotivo
    def get_infRec(self): return self.infRec
    def set_infRec(self, infRec): self.infRec = infRec
    def get_versao(self): return self.versao
    def set_versao(self, versao): self.versao = versao
    def validate_TVerCTe(self, value):
        # Validate type TVerCTe, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.tpAmb is not None or
            self.cUF is not None or
            self.verAplic is not None or
            self.cStat is not None or
            self.xMotivo is not None or
            self.infRec is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TRetEnviCTe', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TRetEnviCTe')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TRetEnviCTe')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TRetEnviCTe', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TRetEnviCTe'):
        if self.versao is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            outfile.write(' versao=%s' % (quote_attrib(self.versao), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TRetEnviCTe', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpAmb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpAmb>%s</%stpAmb>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.tpAmb), input_name='tpAmb')), namespace_, eol_))
        if self.cUF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scUF>%s</%scUF>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.cUF), input_name='cUF')), namespace_, eol_))
        if self.verAplic is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sverAplic>%s</%sverAplic>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.verAplic), input_name='verAplic')), namespace_, eol_))
        if self.cStat is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scStat>%s</%scStat>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.cStat), input_name='cStat')), namespace_, eol_))
        if self.xMotivo is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxMotivo>%s</%sxMotivo>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.xMotivo), input_name='xMotivo')), namespace_, eol_))
        if self.infRec is not None:
            self.infRec.export(outfile, level, namespace_, name_='infRec', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('versao', node)
        if value is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            self.versao = value
            self.validate_TVerCTe(self.versao)    # validate type TVerCTe
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tpAmb':
            tpAmb_ = child_.text
            tpAmb_ = self.gds_validate_string(tpAmb_, node, 'tpAmb')
            self.tpAmb = tpAmb_
        elif nodeName_ == 'cUF':
            cUF_ = child_.text
            cUF_ = self.gds_validate_string(cUF_, node, 'cUF')
            self.cUF = cUF_
        elif nodeName_ == 'verAplic':
            verAplic_ = child_.text
            verAplic_ = self.gds_validate_string(verAplic_, node, 'verAplic')
            self.verAplic = verAplic_
        elif nodeName_ == 'cStat':
            cStat_ = child_.text
            cStat_ = self.gds_validate_string(cStat_, node, 'cStat')
            self.cStat = cStat_
        elif nodeName_ == 'xMotivo':
            xMotivo_ = child_.text
            xMotivo_ = self.gds_validate_string(xMotivo_, node, 'xMotivo')
            self.xMotivo = xMotivo_
        elif nodeName_ == 'infRec':
            obj_ = infRec.factory()
            obj_.build(child_)
            self.infRec = obj_
            obj_.original_tagname_ = 'infRec'
# end class TRetEnviCTe


class infRec(GeneratedsSuper):
    """Dados do Recibo do Lote"""
    subclass = None
    superclass = None
    def __init__(self, nRec=None, dhRecbto=None, tMed=None):
        self.original_tagname_ = None
        self.nRec = nRec
        self.dhRecbto = dhRecbto
        self.tMed = tMed
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infRec)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infRec.subclass:
            return infRec.subclass(*args_, **kwargs_)
        else:
            return infRec(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nRec(self): return self.nRec
    def set_nRec(self, nRec): self.nRec = nRec
    def get_dhRecbto(self): return self.dhRecbto
    def set_dhRecbto(self, dhRecbto): self.dhRecbto = dhRecbto
    def get_tMed(self): return self.tMed
    def set_tMed(self, tMed): self.tMed = tMed
    def hasContent_(self):
        if (
            self.nRec is not None or
            self.dhRecbto is not None or
            self.tMed is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infRec', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infRec')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infRec')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infRec', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infRec'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infRec', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nRec is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snRec>%s</%snRec>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.nRec), input_name='nRec')), namespace_, eol_))
        if self.dhRecbto is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdhRecbto>%s</%sdhRecbto>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.dhRecbto), input_name='dhRecbto')), namespace_, eol_))
        if self.tMed is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stMed>%s</%stMed>%s' % (namespace_, self.gds_format_integer(self.tMed, input_name='tMed'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nRec':
            nRec_ = child_.text
            nRec_ = self.gds_validate_string(nRec_, node, 'nRec')
            self.nRec = nRec_
        elif nodeName_ == 'dhRecbto':
            dhRecbto_ = child_.text
            dhRecbto_ = self.gds_validate_string(dhRecbto_, node, 'dhRecbto')
            self.dhRecbto = dhRecbto_
        elif nodeName_ == 'tMed':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'tMed')
            self.tMed = ival_
# end class infRec


class tMed(GeneratedsSuper):
    """Tempo médio de resposta do serviço (em segundos) dos últimos 5
    minutos"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tMed)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tMed.subclass:
            return tMed.subclass(*args_, **kwargs_)
        else:
            return tMed(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='tMed', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tMed')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tMed')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='tMed', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='tMed'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='tMed', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class tMed


class TEndeEmi(GeneratedsSuper):
    """Tipo Dados do Endereço"""
    subclass = None
    superclass = None
    def __init__(self, xLgr=None, nro=None, xCpl=None, xBairro=None, cMun=None, xMun=None, CEP=None, UF=None, fone=None):
        self.original_tagname_ = None
        self.xLgr = xLgr
        self.nro = nro
        self.xCpl = xCpl
        self.xBairro = xBairro
        self.cMun = cMun
        self.xMun = xMun
        self.CEP = CEP
        self.UF = UF
        self.fone = fone
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TEndeEmi)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TEndeEmi.subclass:
            return TEndeEmi.subclass(*args_, **kwargs_)
        else:
            return TEndeEmi(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_xLgr(self): return self.xLgr
    def set_xLgr(self, xLgr): self.xLgr = xLgr
    def get_nro(self): return self.nro
    def set_nro(self, nro): self.nro = nro
    def get_xCpl(self): return self.xCpl
    def set_xCpl(self, xCpl): self.xCpl = xCpl
    def get_xBairro(self): return self.xBairro
    def set_xBairro(self, xBairro): self.xBairro = xBairro
    def get_cMun(self): return self.cMun
    def set_cMun(self, cMun): self.cMun = cMun
    def get_xMun(self): return self.xMun
    def set_xMun(self, xMun): self.xMun = xMun
    def get_CEP(self): return self.CEP
    def set_CEP(self, CEP): self.CEP = CEP
    def get_UF(self): return self.UF
    def set_UF(self, UF): self.UF = UF
    def get_fone(self): return self.fone
    def set_fone(self, fone): self.fone = fone
    def hasContent_(self):
        if (
            self.xLgr is not None or
            self.nro is not None or
            self.xCpl is not None or
            self.xBairro is not None or
            self.cMun is not None or
            self.xMun is not None or
            self.CEP is not None or
            self.UF is not None or
            self.fone is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TEndeEmi', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TEndeEmi')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TEndeEmi')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TEndeEmi', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TEndeEmi'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TEndeEmi', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.xLgr is not None:
            self.xLgr.export(outfile, level, namespace_, name_='xLgr', pretty_print=pretty_print)
        if self.nro is not None:
            self.nro.export(outfile, level, namespace_, name_='nro', pretty_print=pretty_print)
        if self.xCpl is not None:
            self.xCpl.export(outfile, level, namespace_, name_='xCpl', pretty_print=pretty_print)
        if self.xBairro is not None:
            self.xBairro.export(outfile, level, namespace_, name_='xBairro', pretty_print=pretty_print)
        if self.cMun is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scMun>%s</%scMun>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.cMun), input_name='cMun')), namespace_, eol_))
        if self.xMun is not None:
            self.xMun.export(outfile, level, namespace_, name_='xMun', pretty_print=pretty_print)
        if self.CEP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCEP>%s</%sCEP>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CEP), input_name='CEP')), namespace_, eol_))
        if self.UF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUF>%s</%sUF>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.UF), input_name='UF')), namespace_, eol_))
        if self.fone is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfone>%s</%sfone>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.fone), input_name='fone')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'xLgr':
            obj_ = None
            self.xLgr = obj_
            obj_.original_tagname_ = 'xLgr'
        elif nodeName_ == 'nro':
            obj_ = None
            self.nro = obj_
            obj_.original_tagname_ = 'nro'
        elif nodeName_ == 'xCpl':
            obj_ = None
            self.xCpl = obj_
            obj_.original_tagname_ = 'xCpl'
        elif nodeName_ == 'xBairro':
            obj_ = None
            self.xBairro = obj_
            obj_.original_tagname_ = 'xBairro'
        elif nodeName_ == 'cMun':
            cMun_ = child_.text
            cMun_ = self.gds_validate_string(cMun_, node, 'cMun')
            self.cMun = cMun_
        elif nodeName_ == 'xMun':
            obj_ = None
            self.xMun = obj_
            obj_.original_tagname_ = 'xMun'
        elif nodeName_ == 'CEP':
            CEP_ = child_.text
            CEP_ = self.gds_validate_string(CEP_, node, 'CEP')
            self.CEP = CEP_
        elif nodeName_ == 'UF':
            UF_ = child_.text
            UF_ = self.gds_validate_string(UF_, node, 'UF')
            self.UF = UF_
        elif nodeName_ == 'fone':
            fone_ = child_.text
            fone_ = self.gds_validate_string(fone_, node, 'fone')
            self.fone = fone_
# end class TEndeEmi


class xLgr(GeneratedsSuper):
    """Logradouro"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, xLgr)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if xLgr.subclass:
            return xLgr.subclass(*args_, **kwargs_)
        else:
            return xLgr(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='xLgr', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('xLgr')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='xLgr')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='xLgr', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='xLgr'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='xLgr', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class xLgr


class xCpl(GeneratedsSuper):
    """Complemento"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, xCpl)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if xCpl.subclass:
            return xCpl.subclass(*args_, **kwargs_)
        else:
            return xCpl(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='xCpl', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('xCpl')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='xCpl')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='xCpl', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='xCpl'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='xCpl', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class xCpl


class xBairro(GeneratedsSuper):
    """Bairro"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, xBairro)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if xBairro.subclass:
            return xBairro.subclass(*args_, **kwargs_)
        else:
            return xBairro(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='xBairro', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('xBairro')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='xBairro')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='xBairro', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='xBairro'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='xBairro', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class xBairro


class xMun(GeneratedsSuper):
    """Nome do município"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, xMun)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if xMun.subclass:
            return xMun.subclass(*args_, **kwargs_)
        else:
            return xMun(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='xMun', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('xMun')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='xMun')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='xMun', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='xMun'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='xMun', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class xMun


class CEP(GeneratedsSuper):
    """CEPInformar zeros não significativos"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CEP)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CEP.subclass:
            return CEP.subclass(*args_, **kwargs_)
        else:
            return CEP(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CEP', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CEP')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CEP')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CEP', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CEP'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CEP', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CEP


class TEndereco(GeneratedsSuper):
    """Tipo Dados do Endereço"""
    subclass = None
    superclass = None
    def __init__(self, xLgr=None, nro=None, xCpl=None, xBairro=None, cMun=None, xMun=None, CEP=None, UF=None, cPais=None, xPais=None):
        self.original_tagname_ = None
        self.xLgr = xLgr
        self.nro = nro
        self.xCpl = xCpl
        self.xBairro = xBairro
        self.cMun = cMun
        self.xMun = xMun
        self.CEP = CEP
        self.UF = UF
        self.cPais = cPais
        self.xPais = xPais
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TEndereco)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TEndereco.subclass:
            return TEndereco.subclass(*args_, **kwargs_)
        else:
            return TEndereco(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_xLgr(self): return self.xLgr
    def set_xLgr(self, xLgr): self.xLgr = xLgr
    def get_nro(self): return self.nro
    def set_nro(self, nro): self.nro = nro
    def get_xCpl(self): return self.xCpl
    def set_xCpl(self, xCpl): self.xCpl = xCpl
    def get_xBairro(self): return self.xBairro
    def set_xBairro(self, xBairro): self.xBairro = xBairro
    def get_cMun(self): return self.cMun
    def set_cMun(self, cMun): self.cMun = cMun
    def get_xMun(self): return self.xMun
    def set_xMun(self, xMun): self.xMun = xMun
    def get_CEP(self): return self.CEP
    def set_CEP(self, CEP): self.CEP = CEP
    def get_UF(self): return self.UF
    def set_UF(self, UF): self.UF = UF
    def get_cPais(self): return self.cPais
    def set_cPais(self, cPais): self.cPais = cPais
    def get_xPais(self): return self.xPais
    def set_xPais(self, xPais): self.xPais = xPais
    def hasContent_(self):
        if (
            self.xLgr is not None or
            self.nro is not None or
            self.xCpl is not None or
            self.xBairro is not None or
            self.cMun is not None or
            self.xMun is not None or
            self.CEP is not None or
            self.UF is not None or
            self.cPais is not None or
            self.xPais is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TEndereco', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TEndereco')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TEndereco')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TEndereco', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TEndereco'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TEndereco', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.xLgr is not None:
            self.xLgr.export(outfile, level, namespace_, name_='xLgr', pretty_print=pretty_print)
        if self.nro is not None:
            self.nro.export(outfile, level, namespace_, name_='nro', pretty_print=pretty_print)
        if self.xCpl is not None:
            self.xCpl.export(outfile, level, namespace_, name_='xCpl', pretty_print=pretty_print)
        if self.xBairro is not None:
            self.xBairro.export(outfile, level, namespace_, name_='xBairro', pretty_print=pretty_print)
        if self.cMun is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scMun>%s</%scMun>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.cMun), input_name='cMun')), namespace_, eol_))
        if self.xMun is not None:
            self.xMun.export(outfile, level, namespace_, name_='xMun', pretty_print=pretty_print)
        if self.CEP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCEP>%s</%sCEP>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CEP), input_name='CEP')), namespace_, eol_))
        if self.UF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUF>%s</%sUF>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.UF), input_name='UF')), namespace_, eol_))
        if self.cPais is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scPais>%s</%scPais>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.cPais), input_name='cPais')), namespace_, eol_))
        if self.xPais is not None:
            self.xPais.export(outfile, level, namespace_, name_='xPais', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'xLgr':
            obj_ = None
            self.xLgr = obj_
            obj_.original_tagname_ = 'xLgr'
        elif nodeName_ == 'nro':
            obj_ = None
            self.nro = obj_
            obj_.original_tagname_ = 'nro'
        elif nodeName_ == 'xCpl':
            obj_ = None
            self.xCpl = obj_
            obj_.original_tagname_ = 'xCpl'
        elif nodeName_ == 'xBairro':
            obj_ = None
            self.xBairro = obj_
            obj_.original_tagname_ = 'xBairro'
        elif nodeName_ == 'cMun':
            cMun_ = child_.text
            cMun_ = self.gds_validate_string(cMun_, node, 'cMun')
            self.cMun = cMun_
        elif nodeName_ == 'xMun':
            obj_ = None
            self.xMun = obj_
            obj_.original_tagname_ = 'xMun'
        elif nodeName_ == 'CEP':
            CEP_ = child_.text
            CEP_ = self.gds_validate_string(CEP_, node, 'CEP')
            self.CEP = CEP_
        elif nodeName_ == 'UF':
            UF_ = child_.text
            UF_ = self.gds_validate_string(UF_, node, 'UF')
            self.UF = UF_
        elif nodeName_ == 'cPais':
            cPais_ = child_.text
            cPais_ = self.gds_validate_string(cPais_, node, 'cPais')
            self.cPais = cPais_
        elif nodeName_ == 'xPais':
            obj_ = None
            self.xPais = obj_
            obj_.original_tagname_ = 'xPais'
# end class TEndereco


class cPais(GeneratedsSuper):
    """Código do paísUtilizar a tabela do BACEN"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cPais)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cPais.subclass:
            return cPais.subclass(*args_, **kwargs_)
        else:
            return cPais(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cPais', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cPais')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cPais')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='cPais', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cPais'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='cPais', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cPais


class xPais(GeneratedsSuper):
    """Nome do país"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, xPais)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if xPais.subclass:
            return xPais.subclass(*args_, **kwargs_)
        else:
            return xPais(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='xPais', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('xPais')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='xPais')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='xPais', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='xPais'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='xPais', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class xPais


class TEndernac(GeneratedsSuper):
    """Tipo Dados do Endereço"""
    subclass = None
    superclass = None
    def __init__(self, xLgr=None, nro=None, xCpl=None, xBairro=None, cMun=None, xMun=None, CEP=None, UF=None):
        self.original_tagname_ = None
        self.xLgr = xLgr
        self.nro = nro
        self.xCpl = xCpl
        self.xBairro = xBairro
        self.cMun = cMun
        self.xMun = xMun
        self.CEP = CEP
        self.UF = UF
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TEndernac)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TEndernac.subclass:
            return TEndernac.subclass(*args_, **kwargs_)
        else:
            return TEndernac(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_xLgr(self): return self.xLgr
    def set_xLgr(self, xLgr): self.xLgr = xLgr
    def get_nro(self): return self.nro
    def set_nro(self, nro): self.nro = nro
    def get_xCpl(self): return self.xCpl
    def set_xCpl(self, xCpl): self.xCpl = xCpl
    def get_xBairro(self): return self.xBairro
    def set_xBairro(self, xBairro): self.xBairro = xBairro
    def get_cMun(self): return self.cMun
    def set_cMun(self, cMun): self.cMun = cMun
    def get_xMun(self): return self.xMun
    def set_xMun(self, xMun): self.xMun = xMun
    def get_CEP(self): return self.CEP
    def set_CEP(self, CEP): self.CEP = CEP
    def get_UF(self): return self.UF
    def set_UF(self, UF): self.UF = UF
    def hasContent_(self):
        if (
            self.xLgr is not None or
            self.nro is not None or
            self.xCpl is not None or
            self.xBairro is not None or
            self.cMun is not None or
            self.xMun is not None or
            self.CEP is not None or
            self.UF is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TEndernac', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TEndernac')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TEndernac')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TEndernac', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TEndernac'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TEndernac', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.xLgr is not None:
            self.xLgr.export(outfile, level, namespace_, name_='xLgr', pretty_print=pretty_print)
        if self.nro is not None:
            self.nro.export(outfile, level, namespace_, name_='nro', pretty_print=pretty_print)
        if self.xCpl is not None:
            self.xCpl.export(outfile, level, namespace_, name_='xCpl', pretty_print=pretty_print)
        if self.xBairro is not None:
            self.xBairro.export(outfile, level, namespace_, name_='xBairro', pretty_print=pretty_print)
        if self.cMun is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scMun>%s</%scMun>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.cMun), input_name='cMun')), namespace_, eol_))
        if self.xMun is not None:
            self.xMun.export(outfile, level, namespace_, name_='xMun', pretty_print=pretty_print)
        if self.CEP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCEP>%s</%sCEP>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CEP), input_name='CEP')), namespace_, eol_))
        if self.UF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUF>%s</%sUF>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.UF), input_name='UF')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'xLgr':
            obj_ = None
            self.xLgr = obj_
            obj_.original_tagname_ = 'xLgr'
        elif nodeName_ == 'nro':
            obj_ = None
            self.nro = obj_
            obj_.original_tagname_ = 'nro'
        elif nodeName_ == 'xCpl':
            obj_ = None
            self.xCpl = obj_
            obj_.original_tagname_ = 'xCpl'
        elif nodeName_ == 'xBairro':
            obj_ = None
            self.xBairro = obj_
            obj_.original_tagname_ = 'xBairro'
        elif nodeName_ == 'cMun':
            cMun_ = child_.text
            cMun_ = self.gds_validate_string(cMun_, node, 'cMun')
            self.cMun = cMun_
        elif nodeName_ == 'xMun':
            obj_ = None
            self.xMun = obj_
            obj_.original_tagname_ = 'xMun'
        elif nodeName_ == 'CEP':
            CEP_ = child_.text
            CEP_ = self.gds_validate_string(CEP_, node, 'CEP')
            self.CEP = CEP_
        elif nodeName_ == 'UF':
            UF_ = child_.text
            UF_ = self.gds_validate_string(UF_, node, 'UF')
            self.UF = UF_
# end class TEndernac


class TEndOrg(GeneratedsSuper):
    """Tipo Dados do Endereço"""
    subclass = None
    superclass = None
    def __init__(self, xLgr=None, nro=None, xCpl=None, xBairro=None, cMun=None, xMun=None, CEP=None, UF=None, cPais=None, xPais=None, fone=None):
        self.original_tagname_ = None
        self.xLgr = xLgr
        self.nro = nro
        self.xCpl = xCpl
        self.xBairro = xBairro
        self.cMun = cMun
        self.xMun = xMun
        self.CEP = CEP
        self.UF = UF
        self.cPais = cPais
        self.xPais = xPais
        self.fone = fone
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TEndOrg)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TEndOrg.subclass:
            return TEndOrg.subclass(*args_, **kwargs_)
        else:
            return TEndOrg(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_xLgr(self): return self.xLgr
    def set_xLgr(self, xLgr): self.xLgr = xLgr
    def get_nro(self): return self.nro
    def set_nro(self, nro): self.nro = nro
    def get_xCpl(self): return self.xCpl
    def set_xCpl(self, xCpl): self.xCpl = xCpl
    def get_xBairro(self): return self.xBairro
    def set_xBairro(self, xBairro): self.xBairro = xBairro
    def get_cMun(self): return self.cMun
    def set_cMun(self, cMun): self.cMun = cMun
    def get_xMun(self): return self.xMun
    def set_xMun(self, xMun): self.xMun = xMun
    def get_CEP(self): return self.CEP
    def set_CEP(self, CEP): self.CEP = CEP
    def get_UF(self): return self.UF
    def set_UF(self, UF): self.UF = UF
    def get_cPais(self): return self.cPais
    def set_cPais(self, cPais): self.cPais = cPais
    def get_xPais(self): return self.xPais
    def set_xPais(self, xPais): self.xPais = xPais
    def get_fone(self): return self.fone
    def set_fone(self, fone): self.fone = fone
    def hasContent_(self):
        if (
            self.xLgr is not None or
            self.nro is not None or
            self.xCpl is not None or
            self.xBairro is not None or
            self.cMun is not None or
            self.xMun is not None or
            self.CEP is not None or
            self.UF is not None or
            self.cPais is not None or
            self.xPais is not None or
            self.fone is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TEndOrg', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TEndOrg')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TEndOrg')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TEndOrg', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TEndOrg'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TEndOrg', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.xLgr is not None:
            self.xLgr.export(outfile, level, namespace_, name_='xLgr', pretty_print=pretty_print)
        if self.nro is not None:
            self.nro.export(outfile, level, namespace_, name_='nro', pretty_print=pretty_print)
        if self.xCpl is not None:
            self.xCpl.export(outfile, level, namespace_, name_='xCpl', pretty_print=pretty_print)
        if self.xBairro is not None:
            self.xBairro.export(outfile, level, namespace_, name_='xBairro', pretty_print=pretty_print)
        if self.cMun is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scMun>%s</%scMun>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.cMun), input_name='cMun')), namespace_, eol_))
        if self.xMun is not None:
            self.xMun.export(outfile, level, namespace_, name_='xMun', pretty_print=pretty_print)
        if self.CEP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCEP>%s</%sCEP>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CEP), input_name='CEP')), namespace_, eol_))
        if self.UF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUF>%s</%sUF>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.UF), input_name='UF')), namespace_, eol_))
        if self.cPais is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scPais>%s</%scPais>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.cPais), input_name='cPais')), namespace_, eol_))
        if self.xPais is not None:
            self.xPais.export(outfile, level, namespace_, name_='xPais', pretty_print=pretty_print)
        if self.fone is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfone>%s</%sfone>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.fone), input_name='fone')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'xLgr':
            obj_ = None
            self.xLgr = obj_
            obj_.original_tagname_ = 'xLgr'
        elif nodeName_ == 'nro':
            obj_ = None
            self.nro = obj_
            obj_.original_tagname_ = 'nro'
        elif nodeName_ == 'xCpl':
            obj_ = None
            self.xCpl = obj_
            obj_.original_tagname_ = 'xCpl'
        elif nodeName_ == 'xBairro':
            obj_ = None
            self.xBairro = obj_
            obj_.original_tagname_ = 'xBairro'
        elif nodeName_ == 'cMun':
            cMun_ = child_.text
            cMun_ = self.gds_validate_string(cMun_, node, 'cMun')
            self.cMun = cMun_
        elif nodeName_ == 'xMun':
            obj_ = None
            self.xMun = obj_
            obj_.original_tagname_ = 'xMun'
        elif nodeName_ == 'CEP':
            CEP_ = child_.text
            CEP_ = self.gds_validate_string(CEP_, node, 'CEP')
            self.CEP = CEP_
        elif nodeName_ == 'UF':
            UF_ = child_.text
            UF_ = self.gds_validate_string(UF_, node, 'UF')
            self.UF = UF_
        elif nodeName_ == 'cPais':
            cPais_ = child_.text
            cPais_ = self.gds_validate_string(cPais_, node, 'cPais')
            self.cPais = cPais_
        elif nodeName_ == 'xPais':
            obj_ = None
            self.xPais = obj_
            obj_.original_tagname_ = 'xPais'
        elif nodeName_ == 'fone':
            fone_ = child_.text
            fone_ = self.gds_validate_string(fone_, node, 'fone')
            self.fone = fone_
# end class TEndOrg


class TLocal(GeneratedsSuper):
    """Tipo Dados do Local de Origem ou Destino"""
    subclass = None
    superclass = None
    def __init__(self, cMun=None, xMun=None, UF=None):
        self.original_tagname_ = None
        self.cMun = cMun
        self.xMun = xMun
        self.UF = UF
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TLocal)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TLocal.subclass:
            return TLocal.subclass(*args_, **kwargs_)
        else:
            return TLocal(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cMun(self): return self.cMun
    def set_cMun(self, cMun): self.cMun = cMun
    def get_xMun(self): return self.xMun
    def set_xMun(self, xMun): self.xMun = xMun
    def get_UF(self): return self.UF
    def set_UF(self, UF): self.UF = UF
    def hasContent_(self):
        if (
            self.cMun is not None or
            self.xMun is not None or
            self.UF is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TLocal', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TLocal')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TLocal')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TLocal', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TLocal'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TLocal', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cMun is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scMun>%s</%scMun>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.cMun), input_name='cMun')), namespace_, eol_))
        if self.xMun is not None:
            self.xMun.export(outfile, level, namespace_, name_='xMun', pretty_print=pretty_print)
        if self.UF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUF>%s</%sUF>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.UF), input_name='UF')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cMun':
            cMun_ = child_.text
            cMun_ = self.gds_validate_string(cMun_, node, 'cMun')
            self.cMun = cMun_
        elif nodeName_ == 'xMun':
            obj_ = None
            self.xMun = obj_
            obj_.original_tagname_ = 'xMun'
        elif nodeName_ == 'UF':
            UF_ = child_.text
            UF_ = self.gds_validate_string(UF_, node, 'UF')
            self.UF = UF_
# end class TLocal


class TEndReEnt(GeneratedsSuper):
    """Tipo Dados do Local de Retirada ou Entrega"""
    subclass = None
    superclass = None
    def __init__(self, CNPJ=None, CPF=None, xNome=None, xLgr=None, nro=None, xCpl=None, xBairro=None, cMun=None, xMun=None, UF=None):
        self.original_tagname_ = None
        self.CNPJ = CNPJ
        self.CPF = CPF
        self.xNome = xNome
        self.xLgr = xLgr
        self.nro = nro
        self.xCpl = xCpl
        self.xBairro = xBairro
        self.cMun = cMun
        self.xMun = xMun
        self.UF = UF
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TEndReEnt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TEndReEnt.subclass:
            return TEndReEnt.subclass(*args_, **kwargs_)
        else:
            return TEndReEnt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CNPJ(self): return self.CNPJ
    def set_CNPJ(self, CNPJ): self.CNPJ = CNPJ
    def get_CPF(self): return self.CPF
    def set_CPF(self, CPF): self.CPF = CPF
    def get_xNome(self): return self.xNome
    def set_xNome(self, xNome): self.xNome = xNome
    def get_xLgr(self): return self.xLgr
    def set_xLgr(self, xLgr): self.xLgr = xLgr
    def get_nro(self): return self.nro
    def set_nro(self, nro): self.nro = nro
    def get_xCpl(self): return self.xCpl
    def set_xCpl(self, xCpl): self.xCpl = xCpl
    def get_xBairro(self): return self.xBairro
    def set_xBairro(self, xBairro): self.xBairro = xBairro
    def get_cMun(self): return self.cMun
    def set_cMun(self, cMun): self.cMun = cMun
    def get_xMun(self): return self.xMun
    def set_xMun(self, xMun): self.xMun = xMun
    def get_UF(self): return self.UF
    def set_UF(self, UF): self.UF = UF
    def hasContent_(self):
        if (
            self.CNPJ is not None or
            self.CPF is not None or
            self.xNome is not None or
            self.xLgr is not None or
            self.nro is not None or
            self.xCpl is not None or
            self.xBairro is not None or
            self.cMun is not None or
            self.xMun is not None or
            self.UF is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TEndReEnt', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TEndReEnt')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TEndReEnt')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TEndReEnt', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TEndReEnt'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TEndReEnt', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CNPJ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCNPJ>%s</%sCNPJ>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CNPJ), input_name='CNPJ')), namespace_, eol_))
        if self.CPF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCPF>%s</%sCPF>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CPF), input_name='CPF')), namespace_, eol_))
        if self.xNome is not None:
            self.xNome.export(outfile, level, namespace_, name_='xNome', pretty_print=pretty_print)
        if self.xLgr is not None:
            self.xLgr.export(outfile, level, namespace_, name_='xLgr', pretty_print=pretty_print)
        if self.nro is not None:
            self.nro.export(outfile, level, namespace_, name_='nro', pretty_print=pretty_print)
        if self.xCpl is not None:
            self.xCpl.export(outfile, level, namespace_, name_='xCpl', pretty_print=pretty_print)
        if self.xBairro is not None:
            self.xBairro.export(outfile, level, namespace_, name_='xBairro', pretty_print=pretty_print)
        if self.cMun is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scMun>%s</%scMun>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.cMun), input_name='cMun')), namespace_, eol_))
        if self.xMun is not None:
            self.xMun.export(outfile, level, namespace_, name_='xMun', pretty_print=pretty_print)
        if self.UF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUF>%s</%sUF>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.UF), input_name='UF')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CNPJ':
            CNPJ_ = child_.text
            CNPJ_ = self.gds_validate_string(CNPJ_, node, 'CNPJ')
            self.CNPJ = CNPJ_
        elif nodeName_ == 'CPF':
            CPF_ = child_.text
            CPF_ = self.gds_validate_string(CPF_, node, 'CPF')
            self.CPF = CPF_
        elif nodeName_ == 'xNome':
            obj_ = None
            self.xNome = obj_
            obj_.original_tagname_ = 'xNome'
        elif nodeName_ == 'xLgr':
            obj_ = None
            self.xLgr = obj_
            obj_.original_tagname_ = 'xLgr'
        elif nodeName_ == 'nro':
            obj_ = None
            self.nro = obj_
            obj_.original_tagname_ = 'nro'
        elif nodeName_ == 'xCpl':
            obj_ = None
            self.xCpl = obj_
            obj_.original_tagname_ = 'xCpl'
        elif nodeName_ == 'xBairro':
            obj_ = None
            self.xBairro = obj_
            obj_.original_tagname_ = 'xBairro'
        elif nodeName_ == 'cMun':
            cMun_ = child_.text
            cMun_ = self.gds_validate_string(cMun_, node, 'cMun')
            self.cMun = cMun_
        elif nodeName_ == 'xMun':
            obj_ = None
            self.xMun = obj_
            obj_.original_tagname_ = 'xMun'
        elif nodeName_ == 'UF':
            UF_ = child_.text
            UF_ = self.gds_validate_string(UF_, node, 'UF')
            self.UF = UF_
# end class TEndReEnt


class TImp(GeneratedsSuper):
    """Tipo Dados do Imposto CT-e"""
    subclass = None
    superclass = None
    def __init__(self, ICMS00=None, ICMS20=None, ICMS45=None, ICMS60=None, ICMS90=None, ICMSOutraUF=None, ICMSSN=None):
        self.original_tagname_ = None
        self.ICMS00 = ICMS00
        self.ICMS20 = ICMS20
        self.ICMS45 = ICMS45
        self.ICMS60 = ICMS60
        self.ICMS90 = ICMS90
        self.ICMSOutraUF = ICMSOutraUF
        self.ICMSSN = ICMSSN
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TImp)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TImp.subclass:
            return TImp.subclass(*args_, **kwargs_)
        else:
            return TImp(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ICMS00(self): return self.ICMS00
    def set_ICMS00(self, ICMS00): self.ICMS00 = ICMS00
    def get_ICMS20(self): return self.ICMS20
    def set_ICMS20(self, ICMS20): self.ICMS20 = ICMS20
    def get_ICMS45(self): return self.ICMS45
    def set_ICMS45(self, ICMS45): self.ICMS45 = ICMS45
    def get_ICMS60(self): return self.ICMS60
    def set_ICMS60(self, ICMS60): self.ICMS60 = ICMS60
    def get_ICMS90(self): return self.ICMS90
    def set_ICMS90(self, ICMS90): self.ICMS90 = ICMS90
    def get_ICMSOutraUF(self): return self.ICMSOutraUF
    def set_ICMSOutraUF(self, ICMSOutraUF): self.ICMSOutraUF = ICMSOutraUF
    def get_ICMSSN(self): return self.ICMSSN
    def set_ICMSSN(self, ICMSSN): self.ICMSSN = ICMSSN
    def hasContent_(self):
        if (
            self.ICMS00 is not None or
            self.ICMS20 is not None or
            self.ICMS45 is not None or
            self.ICMS60 is not None or
            self.ICMS90 is not None or
            self.ICMSOutraUF is not None or
            self.ICMSSN is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TImp', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TImp')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TImp')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TImp', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TImp'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TImp', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ICMS00 is not None:
            self.ICMS00.export(outfile, level, namespace_, name_='ICMS00', pretty_print=pretty_print)
        if self.ICMS20 is not None:
            self.ICMS20.export(outfile, level, namespace_, name_='ICMS20', pretty_print=pretty_print)
        if self.ICMS45 is not None:
            self.ICMS45.export(outfile, level, namespace_, name_='ICMS45', pretty_print=pretty_print)
        if self.ICMS60 is not None:
            self.ICMS60.export(outfile, level, namespace_, name_='ICMS60', pretty_print=pretty_print)
        if self.ICMS90 is not None:
            self.ICMS90.export(outfile, level, namespace_, name_='ICMS90', pretty_print=pretty_print)
        if self.ICMSOutraUF is not None:
            self.ICMSOutraUF.export(outfile, level, namespace_, name_='ICMSOutraUF', pretty_print=pretty_print)
        if self.ICMSSN is not None:
            self.ICMSSN.export(outfile, level, namespace_, name_='ICMSSN', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ICMS00':
            obj_ = ICMS00.factory()
            obj_.build(child_)
            self.ICMS00 = obj_
            obj_.original_tagname_ = 'ICMS00'
        elif nodeName_ == 'ICMS20':
            obj_ = ICMS20.factory()
            obj_.build(child_)
            self.ICMS20 = obj_
            obj_.original_tagname_ = 'ICMS20'
        elif nodeName_ == 'ICMS45':
            obj_ = ICMS45.factory()
            obj_.build(child_)
            self.ICMS45 = obj_
            obj_.original_tagname_ = 'ICMS45'
        elif nodeName_ == 'ICMS60':
            obj_ = ICMS60.factory()
            obj_.build(child_)
            self.ICMS60 = obj_
            obj_.original_tagname_ = 'ICMS60'
        elif nodeName_ == 'ICMS90':
            obj_ = ICMS90.factory()
            obj_.build(child_)
            self.ICMS90 = obj_
            obj_.original_tagname_ = 'ICMS90'
        elif nodeName_ == 'ICMSOutraUF':
            obj_ = ICMSOutraUF.factory()
            obj_.build(child_)
            self.ICMSOutraUF = obj_
            obj_.original_tagname_ = 'ICMSOutraUF'
        elif nodeName_ == 'ICMSSN':
            obj_ = ICMSSN.factory()
            obj_.build(child_)
            self.ICMSSN = obj_
            obj_.original_tagname_ = 'ICMSSN'
# end class TImp


class ICMS00(GeneratedsSuper):
    """Prestação sujeito à tributação normal do ICMS"""
    subclass = None
    superclass = None
    def __init__(self, CST=None, vBC=None, pICMS=None, vICMS=None):
        self.original_tagname_ = None
        self.CST = CST
        self.vBC = vBC
        self.pICMS = pICMS
        self.vICMS = vICMS
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMS00)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMS00.subclass:
            return ICMS00.subclass(*args_, **kwargs_)
        else:
            return ICMS00(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CST(self): return self.CST
    def set_CST(self, CST): self.CST = CST
    def get_vBC(self): return self.vBC
    def set_vBC(self, vBC): self.vBC = vBC
    def get_pICMS(self): return self.pICMS
    def set_pICMS(self, pICMS): self.pICMS = pICMS
    def get_vICMS(self): return self.vICMS
    def set_vICMS(self, vICMS): self.vICMS = vICMS
    def hasContent_(self):
        if (
            self.CST is not None or
            self.vBC is not None or
            self.pICMS is not None or
            self.vICMS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ICMS00', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMS00')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ICMS00')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ICMS00', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ICMS00'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ICMS00', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCST>%s</%sCST>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CST), input_name='CST')), namespace_, eol_))
        if self.vBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBC>%s</%svBC>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.vBC), input_name='vBC')), namespace_, eol_))
        if self.pICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spICMS>%s</%spICMS>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.pICMS), input_name='pICMS')), namespace_, eol_))
        if self.vICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svICMS>%s</%svICMS>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.vICMS), input_name='vICMS')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CST':
            CST_ = child_.text
            CST_ = self.gds_validate_string(CST_, node, 'CST')
            self.CST = CST_
        elif nodeName_ == 'vBC':
            vBC_ = child_.text
            vBC_ = self.gds_validate_string(vBC_, node, 'vBC')
            self.vBC = vBC_
        elif nodeName_ == 'pICMS':
            pICMS_ = child_.text
            pICMS_ = self.gds_validate_string(pICMS_, node, 'pICMS')
            self.pICMS = pICMS_
        elif nodeName_ == 'vICMS':
            vICMS_ = child_.text
            vICMS_ = self.gds_validate_string(vICMS_, node, 'vICMS')
            self.vICMS = vICMS_
# end class ICMS00


class CST(GeneratedsSuper):
    """classificação Tributária do Serviço00 - tributação normal ICMS"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CST)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CST.subclass:
            return CST.subclass(*args_, **kwargs_)
        else:
            return CST(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CST', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CST')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CST')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CST', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CST'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CST', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CST


class ICMS20(GeneratedsSuper):
    """Prestação sujeito à tributação com redução de BC do ICMS"""
    subclass = None
    superclass = None
    def __init__(self, CST=None, pRedBC=None, vBC=None, pICMS=None, vICMS=None):
        self.original_tagname_ = None
        self.CST = CST
        self.pRedBC = pRedBC
        self.vBC = vBC
        self.pICMS = pICMS
        self.vICMS = vICMS
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMS20)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMS20.subclass:
            return ICMS20.subclass(*args_, **kwargs_)
        else:
            return ICMS20(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CST(self): return self.CST
    def set_CST(self, CST): self.CST = CST
    def get_pRedBC(self): return self.pRedBC
    def set_pRedBC(self, pRedBC): self.pRedBC = pRedBC
    def get_vBC(self): return self.vBC
    def set_vBC(self, vBC): self.vBC = vBC
    def get_pICMS(self): return self.pICMS
    def set_pICMS(self, pICMS): self.pICMS = pICMS
    def get_vICMS(self): return self.vICMS
    def set_vICMS(self, vICMS): self.vICMS = vICMS
    def hasContent_(self):
        if (
            self.CST is not None or
            self.pRedBC is not None or
            self.vBC is not None or
            self.pICMS is not None or
            self.vICMS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ICMS20', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMS20')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ICMS20')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ICMS20', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ICMS20'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ICMS20', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCST>%s</%sCST>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CST), input_name='CST')), namespace_, eol_))
        if self.pRedBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spRedBC>%s</%spRedBC>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.pRedBC), input_name='pRedBC')), namespace_, eol_))
        if self.vBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBC>%s</%svBC>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.vBC), input_name='vBC')), namespace_, eol_))
        if self.pICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spICMS>%s</%spICMS>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.pICMS), input_name='pICMS')), namespace_, eol_))
        if self.vICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svICMS>%s</%svICMS>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.vICMS), input_name='vICMS')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CST':
            CST_ = child_.text
            CST_ = self.gds_validate_string(CST_, node, 'CST')
            self.CST = CST_
        elif nodeName_ == 'pRedBC':
            pRedBC_ = child_.text
            pRedBC_ = self.gds_validate_string(pRedBC_, node, 'pRedBC')
            self.pRedBC = pRedBC_
        elif nodeName_ == 'vBC':
            vBC_ = child_.text
            vBC_ = self.gds_validate_string(vBC_, node, 'vBC')
            self.vBC = vBC_
        elif nodeName_ == 'pICMS':
            pICMS_ = child_.text
            pICMS_ = self.gds_validate_string(pICMS_, node, 'pICMS')
            self.pICMS = pICMS_
        elif nodeName_ == 'vICMS':
            vICMS_ = child_.text
            vICMS_ = self.gds_validate_string(vICMS_, node, 'vICMS')
            self.vICMS = vICMS_
# end class ICMS20


class ICMS45(GeneratedsSuper):
    """ICMS Isento, não Tributado ou diferido"""
    subclass = None
    superclass = None
    def __init__(self, CST=None):
        self.original_tagname_ = None
        self.CST = CST
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMS45)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMS45.subclass:
            return ICMS45.subclass(*args_, **kwargs_)
        else:
            return ICMS45(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CST(self): return self.CST
    def set_CST(self, CST): self.CST = CST
    def hasContent_(self):
        if (
            self.CST is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ICMS45', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMS45')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ICMS45')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ICMS45', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ICMS45'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ICMS45', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCST>%s</%sCST>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CST), input_name='CST')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CST':
            CST_ = child_.text
            CST_ = self.gds_validate_string(CST_, node, 'CST')
            self.CST = CST_
# end class ICMS45


class ICMS60(GeneratedsSuper):
    """Tributação pelo ICMS60 - ICMS cobrado por substituição
    tributária.Responsabilidade do recolhimento do ICMS atribuído ao
    tomador ou 3º por ST"""
    subclass = None
    superclass = None
    def __init__(self, CST=None, vBCSTRet=None, vICMSSTRet=None, pICMSSTRet=None, vCred=None):
        self.original_tagname_ = None
        self.CST = CST
        self.vBCSTRet = vBCSTRet
        self.vICMSSTRet = vICMSSTRet
        self.pICMSSTRet = pICMSSTRet
        self.vCred = vCred
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMS60)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMS60.subclass:
            return ICMS60.subclass(*args_, **kwargs_)
        else:
            return ICMS60(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CST(self): return self.CST
    def set_CST(self, CST): self.CST = CST
    def get_vBCSTRet(self): return self.vBCSTRet
    def set_vBCSTRet(self, vBCSTRet): self.vBCSTRet = vBCSTRet
    def get_vICMSSTRet(self): return self.vICMSSTRet
    def set_vICMSSTRet(self, vICMSSTRet): self.vICMSSTRet = vICMSSTRet
    def get_pICMSSTRet(self): return self.pICMSSTRet
    def set_pICMSSTRet(self, pICMSSTRet): self.pICMSSTRet = pICMSSTRet
    def get_vCred(self): return self.vCred
    def set_vCred(self, vCred): self.vCred = vCred
    def hasContent_(self):
        if (
            self.CST is not None or
            self.vBCSTRet is not None or
            self.vICMSSTRet is not None or
            self.pICMSSTRet is not None or
            self.vCred is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ICMS60', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMS60')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ICMS60')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ICMS60', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ICMS60'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ICMS60', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCST>%s</%sCST>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CST), input_name='CST')), namespace_, eol_))
        if self.vBCSTRet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBCSTRet>%s</%svBCSTRet>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.vBCSTRet), input_name='vBCSTRet')), namespace_, eol_))
        if self.vICMSSTRet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svICMSSTRet>%s</%svICMSSTRet>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.vICMSSTRet), input_name='vICMSSTRet')), namespace_, eol_))
        if self.pICMSSTRet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spICMSSTRet>%s</%spICMSSTRet>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.pICMSSTRet), input_name='pICMSSTRet')), namespace_, eol_))
        if self.vCred is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svCred>%s</%svCred>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.vCred), input_name='vCred')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CST':
            CST_ = child_.text
            CST_ = self.gds_validate_string(CST_, node, 'CST')
            self.CST = CST_
        elif nodeName_ == 'vBCSTRet':
            vBCSTRet_ = child_.text
            vBCSTRet_ = self.gds_validate_string(vBCSTRet_, node, 'vBCSTRet')
            self.vBCSTRet = vBCSTRet_
        elif nodeName_ == 'vICMSSTRet':
            vICMSSTRet_ = child_.text
            vICMSSTRet_ = self.gds_validate_string(vICMSSTRet_, node, 'vICMSSTRet')
            self.vICMSSTRet = vICMSSTRet_
        elif nodeName_ == 'pICMSSTRet':
            pICMSSTRet_ = child_.text
            pICMSSTRet_ = self.gds_validate_string(pICMSSTRet_, node, 'pICMSSTRet')
            self.pICMSSTRet = pICMSSTRet_
        elif nodeName_ == 'vCred':
            vCred_ = child_.text
            vCred_ = self.gds_validate_string(vCred_, node, 'vCred')
            self.vCred = vCred_
# end class ICMS60


class ICMS90(GeneratedsSuper):
    """ICMS Outros"""
    subclass = None
    superclass = None
    def __init__(self, CST=None, pRedBC=None, vBC=None, pICMS=None, vICMS=None, vCred=None):
        self.original_tagname_ = None
        self.CST = CST
        self.pRedBC = pRedBC
        self.vBC = vBC
        self.pICMS = pICMS
        self.vICMS = vICMS
        self.vCred = vCred
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMS90)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMS90.subclass:
            return ICMS90.subclass(*args_, **kwargs_)
        else:
            return ICMS90(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CST(self): return self.CST
    def set_CST(self, CST): self.CST = CST
    def get_pRedBC(self): return self.pRedBC
    def set_pRedBC(self, pRedBC): self.pRedBC = pRedBC
    def get_vBC(self): return self.vBC
    def set_vBC(self, vBC): self.vBC = vBC
    def get_pICMS(self): return self.pICMS
    def set_pICMS(self, pICMS): self.pICMS = pICMS
    def get_vICMS(self): return self.vICMS
    def set_vICMS(self, vICMS): self.vICMS = vICMS
    def get_vCred(self): return self.vCred
    def set_vCred(self, vCred): self.vCred = vCred
    def hasContent_(self):
        if (
            self.CST is not None or
            self.pRedBC is not None or
            self.vBC is not None or
            self.pICMS is not None or
            self.vICMS is not None or
            self.vCred is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ICMS90', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMS90')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ICMS90')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ICMS90', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ICMS90'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ICMS90', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCST>%s</%sCST>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CST), input_name='CST')), namespace_, eol_))
        if self.pRedBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spRedBC>%s</%spRedBC>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.pRedBC), input_name='pRedBC')), namespace_, eol_))
        if self.vBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBC>%s</%svBC>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.vBC), input_name='vBC')), namespace_, eol_))
        if self.pICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spICMS>%s</%spICMS>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.pICMS), input_name='pICMS')), namespace_, eol_))
        if self.vICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svICMS>%s</%svICMS>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.vICMS), input_name='vICMS')), namespace_, eol_))
        if self.vCred is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svCred>%s</%svCred>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.vCred), input_name='vCred')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CST':
            CST_ = child_.text
            CST_ = self.gds_validate_string(CST_, node, 'CST')
            self.CST = CST_
        elif nodeName_ == 'pRedBC':
            pRedBC_ = child_.text
            pRedBC_ = self.gds_validate_string(pRedBC_, node, 'pRedBC')
            self.pRedBC = pRedBC_
        elif nodeName_ == 'vBC':
            vBC_ = child_.text
            vBC_ = self.gds_validate_string(vBC_, node, 'vBC')
            self.vBC = vBC_
        elif nodeName_ == 'pICMS':
            pICMS_ = child_.text
            pICMS_ = self.gds_validate_string(pICMS_, node, 'pICMS')
            self.pICMS = pICMS_
        elif nodeName_ == 'vICMS':
            vICMS_ = child_.text
            vICMS_ = self.gds_validate_string(vICMS_, node, 'vICMS')
            self.vICMS = vICMS_
        elif nodeName_ == 'vCred':
            vCred_ = child_.text
            vCred_ = self.gds_validate_string(vCred_, node, 'vCred')
            self.vCred = vCred_
# end class ICMS90


class ICMSOutraUF(GeneratedsSuper):
    """ICMS devido à UF de origem da prestação, quando diferente da UF do
    emitente"""
    subclass = None
    superclass = None
    def __init__(self, CST=None, pRedBCOutraUF=None, vBCOutraUF=None, pICMSOutraUF=None, vICMSOutraUF=None):
        self.original_tagname_ = None
        self.CST = CST
        self.pRedBCOutraUF = pRedBCOutraUF
        self.vBCOutraUF = vBCOutraUF
        self.pICMSOutraUF = pICMSOutraUF
        self.vICMSOutraUF = vICMSOutraUF
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMSOutraUF)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMSOutraUF.subclass:
            return ICMSOutraUF.subclass(*args_, **kwargs_)
        else:
            return ICMSOutraUF(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CST(self): return self.CST
    def set_CST(self, CST): self.CST = CST
    def get_pRedBCOutraUF(self): return self.pRedBCOutraUF
    def set_pRedBCOutraUF(self, pRedBCOutraUF): self.pRedBCOutraUF = pRedBCOutraUF
    def get_vBCOutraUF(self): return self.vBCOutraUF
    def set_vBCOutraUF(self, vBCOutraUF): self.vBCOutraUF = vBCOutraUF
    def get_pICMSOutraUF(self): return self.pICMSOutraUF
    def set_pICMSOutraUF(self, pICMSOutraUF): self.pICMSOutraUF = pICMSOutraUF
    def get_vICMSOutraUF(self): return self.vICMSOutraUF
    def set_vICMSOutraUF(self, vICMSOutraUF): self.vICMSOutraUF = vICMSOutraUF
    def hasContent_(self):
        if (
            self.CST is not None or
            self.pRedBCOutraUF is not None or
            self.vBCOutraUF is not None or
            self.pICMSOutraUF is not None or
            self.vICMSOutraUF is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ICMSOutraUF', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMSOutraUF')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ICMSOutraUF')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ICMSOutraUF', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ICMSOutraUF'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ICMSOutraUF', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCST>%s</%sCST>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CST), input_name='CST')), namespace_, eol_))
        if self.pRedBCOutraUF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spRedBCOutraUF>%s</%spRedBCOutraUF>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.pRedBCOutraUF), input_name='pRedBCOutraUF')), namespace_, eol_))
        if self.vBCOutraUF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBCOutraUF>%s</%svBCOutraUF>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.vBCOutraUF), input_name='vBCOutraUF')), namespace_, eol_))
        if self.pICMSOutraUF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spICMSOutraUF>%s</%spICMSOutraUF>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.pICMSOutraUF), input_name='pICMSOutraUF')), namespace_, eol_))
        if self.vICMSOutraUF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svICMSOutraUF>%s</%svICMSOutraUF>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.vICMSOutraUF), input_name='vICMSOutraUF')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CST':
            CST_ = child_.text
            CST_ = self.gds_validate_string(CST_, node, 'CST')
            self.CST = CST_
        elif nodeName_ == 'pRedBCOutraUF':
            pRedBCOutraUF_ = child_.text
            pRedBCOutraUF_ = self.gds_validate_string(pRedBCOutraUF_, node, 'pRedBCOutraUF')
            self.pRedBCOutraUF = pRedBCOutraUF_
        elif nodeName_ == 'vBCOutraUF':
            vBCOutraUF_ = child_.text
            vBCOutraUF_ = self.gds_validate_string(vBCOutraUF_, node, 'vBCOutraUF')
            self.vBCOutraUF = vBCOutraUF_
        elif nodeName_ == 'pICMSOutraUF':
            pICMSOutraUF_ = child_.text
            pICMSOutraUF_ = self.gds_validate_string(pICMSOutraUF_, node, 'pICMSOutraUF')
            self.pICMSOutraUF = pICMSOutraUF_
        elif nodeName_ == 'vICMSOutraUF':
            vICMSOutraUF_ = child_.text
            vICMSOutraUF_ = self.gds_validate_string(vICMSOutraUF_, node, 'vICMSOutraUF')
            self.vICMSOutraUF = vICMSOutraUF_
# end class ICMSOutraUF


class ICMSSN(GeneratedsSuper):
    """Simples Nacional"""
    subclass = None
    superclass = None
    def __init__(self, CST=None, indSN=None):
        self.original_tagname_ = None
        self.CST = CST
        self.indSN = indSN
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMSSN)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMSSN.subclass:
            return ICMSSN.subclass(*args_, **kwargs_)
        else:
            return ICMSSN(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CST(self): return self.CST
    def set_CST(self, CST): self.CST = CST
    def get_indSN(self): return self.indSN
    def set_indSN(self, indSN): self.indSN = indSN
    def hasContent_(self):
        if (
            self.CST is not None or
            self.indSN is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ICMSSN', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMSSN')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ICMSSN')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ICMSSN', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ICMSSN'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ICMSSN', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCST>%s</%sCST>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CST), input_name='CST')), namespace_, eol_))
        if self.indSN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sindSN>%s</%sindSN>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.indSN), input_name='indSN')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CST':
            CST_ = child_.text
            CST_ = self.gds_validate_string(CST_, node, 'CST')
            self.CST = CST_
        elif nodeName_ == 'indSN':
            indSN_ = child_.text
            indSN_ = self.gds_validate_string(indSN_, node, 'indSN')
            self.indSN = indSN_
# end class ICMSSN


class indSN(GeneratedsSuper):
    """Indica se o contribuinte é Simples Nacional 1=Sim"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, indSN)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if indSN.subclass:
            return indSN.subclass(*args_, **kwargs_)
        else:
            return indSN(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='indSN', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('indSN')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='indSN')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='indSN', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='indSN'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='indSN', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class indSN


class TImpOS(GeneratedsSuper):
    """Tipo Dados do Imposto para CT-e OS"""
    subclass = None
    superclass = None
    def __init__(self, ICMS00=None, ICMS45=None, ICMS90=None, ICMSOutraUF=None, ICMSSN=None):
        self.original_tagname_ = None
        self.ICMS00 = ICMS00
        self.ICMS45 = ICMS45
        self.ICMS90 = ICMS90
        self.ICMSOutraUF = ICMSOutraUF
        self.ICMSSN = ICMSSN
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TImpOS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TImpOS.subclass:
            return TImpOS.subclass(*args_, **kwargs_)
        else:
            return TImpOS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ICMS00(self): return self.ICMS00
    def set_ICMS00(self, ICMS00): self.ICMS00 = ICMS00
    def get_ICMS45(self): return self.ICMS45
    def set_ICMS45(self, ICMS45): self.ICMS45 = ICMS45
    def get_ICMS90(self): return self.ICMS90
    def set_ICMS90(self, ICMS90): self.ICMS90 = ICMS90
    def get_ICMSOutraUF(self): return self.ICMSOutraUF
    def set_ICMSOutraUF(self, ICMSOutraUF): self.ICMSOutraUF = ICMSOutraUF
    def get_ICMSSN(self): return self.ICMSSN
    def set_ICMSSN(self, ICMSSN): self.ICMSSN = ICMSSN
    def hasContent_(self):
        if (
            self.ICMS00 is not None or
            self.ICMS45 is not None or
            self.ICMS90 is not None or
            self.ICMSOutraUF is not None or
            self.ICMSSN is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TImpOS', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TImpOS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TImpOS')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TImpOS', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TImpOS'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TImpOS', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ICMS00 is not None:
            self.ICMS00.export(outfile, level, namespace_, name_='ICMS00', pretty_print=pretty_print)
        if self.ICMS45 is not None:
            self.ICMS45.export(outfile, level, namespace_, name_='ICMS45', pretty_print=pretty_print)
        if self.ICMS90 is not None:
            self.ICMS90.export(outfile, level, namespace_, name_='ICMS90', pretty_print=pretty_print)
        if self.ICMSOutraUF is not None:
            self.ICMSOutraUF.export(outfile, level, namespace_, name_='ICMSOutraUF', pretty_print=pretty_print)
        if self.ICMSSN is not None:
            self.ICMSSN.export(outfile, level, namespace_, name_='ICMSSN', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ICMS00':
            obj_ = ICMS00.factory()
            obj_.build(child_)
            self.ICMS00 = obj_
            obj_.original_tagname_ = 'ICMS00'
        elif nodeName_ == 'ICMS45':
            obj_ = ICMS45.factory()
            obj_.build(child_)
            self.ICMS45 = obj_
            obj_.original_tagname_ = 'ICMS45'
        elif nodeName_ == 'ICMS90':
            obj_ = ICMS90.factory()
            obj_.build(child_)
            self.ICMS90 = obj_
            obj_.original_tagname_ = 'ICMS90'
        elif nodeName_ == 'ICMSOutraUF':
            obj_ = ICMSOutraUF.factory()
            obj_.build(child_)
            self.ICMSOutraUF = obj_
            obj_.original_tagname_ = 'ICMSOutraUF'
        elif nodeName_ == 'ICMSSN':
            obj_ = ICMSSN.factory()
            obj_.build(child_)
            self.ICMSSN = obj_
            obj_.original_tagname_ = 'ICMSSN'
# end class TImpOS


class TUnidadeTransp(GeneratedsSuper):
    """Tipo Dados Unidade de Transporte"""
    subclass = None
    superclass = None
    def __init__(self, tpUnidTransp=None, idUnidTransp=None, lacUnidTransp=None, infUnidCarga=None, qtdRat=None):
        self.original_tagname_ = None
        self.tpUnidTransp = tpUnidTransp
        self.idUnidTransp = idUnidTransp
        self.validate_TContainer(self.idUnidTransp)
        if lacUnidTransp is None:
            self.lacUnidTransp = []
        else:
            self.lacUnidTransp = lacUnidTransp
        if infUnidCarga is None:
            self.infUnidCarga = []
        else:
            self.infUnidCarga = infUnidCarga
        self.qtdRat = qtdRat
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TUnidadeTransp)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TUnidadeTransp.subclass:
            return TUnidadeTransp.subclass(*args_, **kwargs_)
        else:
            return TUnidadeTransp(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tpUnidTransp(self): return self.tpUnidTransp
    def set_tpUnidTransp(self, tpUnidTransp): self.tpUnidTransp = tpUnidTransp
    def get_idUnidTransp(self): return self.idUnidTransp
    def set_idUnidTransp(self, idUnidTransp): self.idUnidTransp = idUnidTransp
    def get_lacUnidTransp(self): return self.lacUnidTransp
    def set_lacUnidTransp(self, lacUnidTransp): self.lacUnidTransp = lacUnidTransp
    def add_lacUnidTransp(self, value): self.lacUnidTransp.append(value)
    def insert_lacUnidTransp_at(self, index, value): self.lacUnidTransp.insert(index, value)
    def replace_lacUnidTransp_at(self, index, value): self.lacUnidTransp[index] = value
    def get_infUnidCarga(self): return self.infUnidCarga
    def set_infUnidCarga(self, infUnidCarga): self.infUnidCarga = infUnidCarga
    def add_infUnidCarga(self, value): self.infUnidCarga.append(value)
    def insert_infUnidCarga_at(self, index, value): self.infUnidCarga.insert(index, value)
    def replace_infUnidCarga_at(self, index, value): self.infUnidCarga[index] = value
    def get_qtdRat(self): return self.qtdRat
    def set_qtdRat(self, qtdRat): self.qtdRat = qtdRat
    def validate_TContainer(self, value):
        # Validate type TContainer, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.tpUnidTransp is not None or
            self.idUnidTransp is not None or
            self.lacUnidTransp or
            self.infUnidCarga or
            self.qtdRat is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TUnidadeTransp', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TUnidadeTransp')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TUnidadeTransp')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TUnidadeTransp', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TUnidadeTransp'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TUnidadeTransp', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpUnidTransp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpUnidTransp>%s</%stpUnidTransp>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.tpUnidTransp), input_name='tpUnidTransp')), namespace_, eol_))
        if self.idUnidTransp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sidUnidTransp>%s</%sidUnidTransp>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.idUnidTransp), input_name='idUnidTransp')), namespace_, eol_))
        for lacUnidTransp_ in self.lacUnidTransp:
            lacUnidTransp_.export(outfile, level, namespace_, name_='lacUnidTransp', pretty_print=pretty_print)
        for infUnidCarga_ in self.infUnidCarga:
            infUnidCarga_.export(outfile, level, namespace_, name_='infUnidCarga', pretty_print=pretty_print)
        if self.qtdRat is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sqtdRat>%s</%sqtdRat>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.qtdRat), input_name='qtdRat')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tpUnidTransp':
            tpUnidTransp_ = child_.text
            tpUnidTransp_ = self.gds_validate_string(tpUnidTransp_, node, 'tpUnidTransp')
            self.tpUnidTransp = tpUnidTransp_
        elif nodeName_ == 'idUnidTransp':
            idUnidTransp_ = child_.text
            idUnidTransp_ = self.gds_validate_string(idUnidTransp_, node, 'idUnidTransp')
            self.idUnidTransp = idUnidTransp_
            # validate type TContainer
            self.validate_TContainer(self.idUnidTransp)
        elif nodeName_ == 'lacUnidTransp':
            obj_ = lacUnidTransp.factory()
            obj_.build(child_)
            self.lacUnidTransp.append(obj_)
            obj_.original_tagname_ = 'lacUnidTransp'
        elif nodeName_ == 'infUnidCarga':
            obj_ = TUnidCarga.factory()
            obj_.build(child_)
            self.infUnidCarga.append(obj_)
            obj_.original_tagname_ = 'infUnidCarga'
        elif nodeName_ == 'qtdRat':
            qtdRat_ = child_.text
            qtdRat_ = self.gds_validate_string(qtdRat_, node, 'qtdRat')
            self.qtdRat = qtdRat_
# end class TUnidadeTransp


class lacUnidTransp(GeneratedsSuper):
    """Lacres das Unidades de Transporte"""
    subclass = None
    superclass = None
    def __init__(self, nLacre=None):
        self.original_tagname_ = None
        self.nLacre = nLacre
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lacUnidTransp)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lacUnidTransp.subclass:
            return lacUnidTransp.subclass(*args_, **kwargs_)
        else:
            return lacUnidTransp(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nLacre(self): return self.nLacre
    def set_nLacre(self, nLacre): self.nLacre = nLacre
    def hasContent_(self):
        if (
            self.nLacre is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='lacUnidTransp', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('lacUnidTransp')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='lacUnidTransp')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='lacUnidTransp', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='lacUnidTransp'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='lacUnidTransp', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nLacre is not None:
            self.nLacre.export(outfile, level, namespace_, name_='nLacre', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nLacre':
            obj_ = None
            self.nLacre = obj_
            obj_.original_tagname_ = 'nLacre'
# end class lacUnidTransp


class nLacre(GeneratedsSuper):
    """Número do lacre"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nLacre)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nLacre.subclass:
            return nLacre.subclass(*args_, **kwargs_)
        else:
            return nLacre(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='nLacre', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('nLacre')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='nLacre')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='nLacre', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='nLacre'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='nLacre', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class nLacre


class TUnidCarga(GeneratedsSuper):
    """Tipo Dados Unidade de Carga"""
    subclass = None
    superclass = None
    def __init__(self, tpUnidCarga=None, idUnidCarga=None, lacUnidCarga=None, qtdRat=None):
        self.original_tagname_ = None
        self.tpUnidCarga = tpUnidCarga
        self.idUnidCarga = idUnidCarga
        self.validate_TContainer(self.idUnidCarga)
        if lacUnidCarga is None:
            self.lacUnidCarga = []
        else:
            self.lacUnidCarga = lacUnidCarga
        self.qtdRat = qtdRat
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TUnidCarga)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TUnidCarga.subclass:
            return TUnidCarga.subclass(*args_, **kwargs_)
        else:
            return TUnidCarga(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tpUnidCarga(self): return self.tpUnidCarga
    def set_tpUnidCarga(self, tpUnidCarga): self.tpUnidCarga = tpUnidCarga
    def get_idUnidCarga(self): return self.idUnidCarga
    def set_idUnidCarga(self, idUnidCarga): self.idUnidCarga = idUnidCarga
    def get_lacUnidCarga(self): return self.lacUnidCarga
    def set_lacUnidCarga(self, lacUnidCarga): self.lacUnidCarga = lacUnidCarga
    def add_lacUnidCarga(self, value): self.lacUnidCarga.append(value)
    def insert_lacUnidCarga_at(self, index, value): self.lacUnidCarga.insert(index, value)
    def replace_lacUnidCarga_at(self, index, value): self.lacUnidCarga[index] = value
    def get_qtdRat(self): return self.qtdRat
    def set_qtdRat(self, qtdRat): self.qtdRat = qtdRat
    def validate_TContainer(self, value):
        # Validate type TContainer, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.tpUnidCarga is not None or
            self.idUnidCarga is not None or
            self.lacUnidCarga or
            self.qtdRat is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TUnidCarga', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TUnidCarga')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TUnidCarga')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TUnidCarga', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TUnidCarga'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TUnidCarga', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpUnidCarga is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpUnidCarga>%s</%stpUnidCarga>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.tpUnidCarga), input_name='tpUnidCarga')), namespace_, eol_))
        if self.idUnidCarga is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sidUnidCarga>%s</%sidUnidCarga>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.idUnidCarga), input_name='idUnidCarga')), namespace_, eol_))
        for lacUnidCarga_ in self.lacUnidCarga:
            lacUnidCarga_.export(outfile, level, namespace_, name_='lacUnidCarga', pretty_print=pretty_print)
        if self.qtdRat is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sqtdRat>%s</%sqtdRat>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.qtdRat), input_name='qtdRat')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tpUnidCarga':
            tpUnidCarga_ = child_.text
            tpUnidCarga_ = self.gds_validate_string(tpUnidCarga_, node, 'tpUnidCarga')
            self.tpUnidCarga = tpUnidCarga_
        elif nodeName_ == 'idUnidCarga':
            idUnidCarga_ = child_.text
            idUnidCarga_ = self.gds_validate_string(idUnidCarga_, node, 'idUnidCarga')
            self.idUnidCarga = idUnidCarga_
            # validate type TContainer
            self.validate_TContainer(self.idUnidCarga)
        elif nodeName_ == 'lacUnidCarga':
            obj_ = lacUnidCarga.factory()
            obj_.build(child_)
            self.lacUnidCarga.append(obj_)
            obj_.original_tagname_ = 'lacUnidCarga'
        elif nodeName_ == 'qtdRat':
            qtdRat_ = child_.text
            qtdRat_ = self.gds_validate_string(qtdRat_, node, 'qtdRat')
            self.qtdRat = qtdRat_
# end class TUnidCarga


class lacUnidCarga(GeneratedsSuper):
    """Lacres das Unidades de Carga"""
    subclass = None
    superclass = None
    def __init__(self, nLacre=None):
        self.original_tagname_ = None
        self.nLacre = nLacre
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lacUnidCarga)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lacUnidCarga.subclass:
            return lacUnidCarga.subclass(*args_, **kwargs_)
        else:
            return lacUnidCarga(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nLacre(self): return self.nLacre
    def set_nLacre(self, nLacre): self.nLacre = nLacre
    def hasContent_(self):
        if (
            self.nLacre is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='lacUnidCarga', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('lacUnidCarga')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='lacUnidCarga')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='lacUnidCarga', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='lacUnidCarga'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='lacUnidCarga', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nLacre is not None:
            self.nLacre.export(outfile, level, namespace_, name_='nLacre', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nLacre':
            obj_ = None
            self.nLacre = obj_
            obj_.original_tagname_ = 'nLacre'
# end class lacUnidCarga


GDSClassesMapping = {
    'CTe': TCTe,
    'ICMS': TImpOS,
    'enderDest': TEndereco,
    'enderEmit': TEndeEmi,
    'enderExped': TEndereco,
    'enderReceb': TEndereco,
    'enderReme': TEndereco,
    'enderToma': TEndereco,
    'infUnidCarga': TUnidCarga,
    'infUnidTransp': TUnidadeTransp,
    'protCTe': TProtCTeOS,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'TProtCTeOS'
        rootClass = TProtCTeOS
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'TProtCTeOS'
        rootClass = TProtCTeOS
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    if sys.version_info.major == 2:
        from StringIO import StringIO as IOBuffer
    else:
        from io import BytesIO as IOBuffer
    parser = None
    doc = parsexml_(IOBuffer(inString), parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'TProtCTeOS'
        rootClass = TProtCTeOS
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'TProtCTeOS'
        rootClass = TProtCTeOS
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from cteTiposBasico import *\n\n')
        sys.stdout.write('import cteTiposBasico as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "TCTe",
    "TCTeOS",
    "TEndOrg",
    "TEndReEnt",
    "TEndeEmi",
    "TEndereco",
    "TEndernac",
    "TEnviCTe",
    "TImp",
    "TImpOS",
    "TLocal",
    "TProtCTeOS",
    "TRetCTeOS",
    "TRetEnviCTe",
    "TUnidCarga",
    "TUnidadeTransp"
]
